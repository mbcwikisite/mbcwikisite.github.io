<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-09-29T16:53:11-04:00</updated><id>http://localhost:4000/</id><title type="html">Simpleyyt</title><subtitle>Too simple, sometimes naive.</subtitle><author><name>Simpleyyt</name></author><entry><title type="html">Google Maglev 简介</title><link href="http://localhost:4000/2017/07/05/introduction-to-google-maglev/" rel="alternate" type="text/html" title="Google Maglev 简介" /><published>2017-07-05T00:00:00-04:00</published><updated>2017-07-05T00:00:00-04:00</updated><id>http://localhost:4000/2017/07/05/introduction-to-google-maglev</id><content type="html" xml:base="http://localhost:4000/2017/07/05/introduction-to-google-maglev/">&lt;p&gt;Google Maglev 是一个牛逼的负载均衡器，之所以牛逼，是因为它不用部署专门的物理设备，不像 LVS 一样工作在内核，它是运行在通用 Linux 服务器上的大型分布式软件系统。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;google-maglev-工作流程&quot;&gt;Google Maglev 工作流程&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/knowledge/3db49483-ce09-4384-9eec-4963db7c0950&quot; alt=&quot;Google Maglev 工作流程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个 Google 服务都有一个或者多个 VIP，一个 VIP 和物理 IP 的区别在于 VIP 没有绑给某个特定的网卡。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VIP 宣告：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Maglev 关联每个 VIP 到具体的 Endpoint，然后通过 BGP 将 VIP 宣告给上游路由器，然后路由器再把 VIP 宣告给 Google 的骨干网，这样使得 VIP 能被访问到。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当用户访问 www.google.com 时：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;浏览器先发送一个 DNS 请求， DNS 服务返回 VIP。 然后浏览器尝试与该 VIP 建立连接。&lt;/li&gt;
  &lt;li&gt;当路由器接收到 VIP 数据包，通过 ECMP 将数据包路由到 Maglev 集群中的某台机器上。&lt;/li&gt;
  &lt;li&gt;当 Maglev 的机器接收到数据包， 从关联到该 VIP 的 Endpoint 中选择一个， 然后用 GRE 封包发送，外层的 IP 即 Endpoint 的物理 IP。&lt;/li&gt;
  &lt;li&gt;当 Endpoint 处理完数据包进行响应时，源地址用 VIP 填充，目的地址为用户 IP。 使用直接服务返回(Direct Server Return， DSR) ，将响应直接发送给路由器， 这样 Maglev 无需处理响应包。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;google-maglev-结构&quot;&gt;Google Maglev 结构&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/knowledge/987eed70-e65e-4bac-a9e5-81ade6deb8a5&quot; alt=&quot;Maglev 结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Maglev 由控制器（Controller）和 转发器（Forwarder）组成：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;控制器向路由器宣告 VIP。&lt;/strong&gt;控制器周期性地检查转发器的健康状态，来宣告或者撤回 VIP。确保路由器只转发包到健康的 Magvel。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;转发器转发 VIP 流量到 Endpoint。&lt;/strong&gt;每个 VIP 都有一个后端池（BP），BP 可能包含 Endpoint 的 IP，也有可能包含其它 BP。每个 BP 会对 Endpoint 进行健康检查，保证数据包转发到健康的 Endpoint。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;转发器的设计和实现&quot;&gt;转发器的设计和实现&lt;/h1&gt;

&lt;h2 id=&quot;转发器结构&quot;&gt;转发器结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/knowledge/68165b8d-e769-499c-8b75-ecca8681600b&quot; alt=&quot;转发器结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;转发器直接从网卡接收数据包，通过 GRE/IP 封包，再将它们发回网卡。 Linux 内核不参与这个过程。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Steering 处理从 NIC（网卡）接收来的数据包，通过五元组（IP地址，源端口，目的IP地址，目的端口和传输层协议）哈希，然后交给不同的接收队列。&lt;/li&gt;
  &lt;li&gt;包重写线程从接收队列取包，然后进行后端选择，用 GRE 封包后，发送到传输队列。&lt;/li&gt;
  &lt;li&gt;Muxing 轮询从所有的传输队列取包，再发送给网卡。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;快速包处理&quot;&gt;快速包处理&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/knowledge/9688207c-2875-4f4c-81d1-81e8681a1fbb&quot; alt=&quot;转发器包处理&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Maglev 在包处理时绕开了 Linux 内核，因为内核开销非常严重。&lt;/p&gt;

&lt;p&gt;如图，转发器和网卡共用数据包池（Packet Pool），转发器中的 Steering 和 Muxing 都通过指针的环形队列，指向该池。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于 Seering：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当网卡接收到数据包时，放在 Recieved 所指位置，并向前移动指针。&lt;/li&gt;
  &lt;li&gt;分发包到接收队列时，向前移动Processed 指针。&lt;/li&gt;
  &lt;li&gt;预留未使用数据包，放入队列中并向前移动 Reserved 指针。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;对于 Muxing：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网卡将 Sent 所指的数据包发出去，并向前移动指针。&lt;/li&gt;
  &lt;li&gt;将被重写的数据包放入队列中，并向前移动 Ready 指针。&lt;/li&gt;
  &lt;li&gt;同时将已被发送的包归回给数据包池，并向前移动 Recycled 指针。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;整个过程都没有包拷贝。&lt;/p&gt;

&lt;h2 id=&quot;后端选择&quot;&gt;后端选择&lt;/h2&gt;

&lt;p&gt;Maglev首先检查本地的连接跟踪表，看看该数据包是否属于任何一个已有的连接，如果连接已经建立，则直接将数据包发到该连接对应的服务器上去。如果连接没有建立，此时就需要一致性哈希函数选择一个后端服务器了，并添加到连接跟踪表。&lt;/p&gt;

&lt;p&gt;Maglev 一致性哈希的基本思想就是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;有一个共享的&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt;表，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry[Hash % M]&lt;/code&gt;选择对应后端，&lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt;表大小。&lt;/li&gt;
  &lt;li&gt;每个后端对所有&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt;表位置有自己的优先级排序，存在&lt;code class=&quot;highlighter-rouge&quot;&gt;permutation&lt;/code&gt;表里。&lt;/li&gt;
  &lt;li&gt;所有的后端通过优先级顺序轮流填充&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt; 中的空白位置，直至填满。每次都填充自己优先级最高的空位置。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如，假设&lt;code class=&quot;highlighter-rouge&quot;&gt;M = 6&lt;/code&gt;，且&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;B0: permutation[] = { 3, 0, 4, 1, 5, 2, 6 }
B1: permutation[] = { 0, 2, 4, 6, 1, 3, 5 }
B2: permutation[] = { 3, 4, 5, 6, 0, 1, 2 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;permutation&lt;/code&gt;优先级是从大到小，那么最后填充后的&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt;表为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry[] = { B1, B0, B1, B0, B2, B2, B0 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;B0 的优先级最高的位置是&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry[3]&lt;/code&gt;，其为空，则&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry[3] = B0&lt;/code&gt;。&lt;/li&gt;
    &lt;li&gt;B1 是&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry[0]&lt;/code&gt;，则&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry[0]=B1&lt;/code&gt;。&lt;/li&gt;
    &lt;li&gt;B2 是&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry[3]&lt;/code&gt;，但是已被占，下一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry[4]&lt;/code&gt;，为空，则&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry[4]=B2&lt;/code&gt;。&lt;/li&gt;
    &lt;li&gt;以此类推，直至填满。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;操作经验&quot;&gt;操作经验&lt;/h1&gt;

&lt;h2 id=&quot;vip-匹配&quot;&gt;VIP 匹配&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/knowledge/cbe69316-d0fd-469a-9692-95948f0cfb51&quot; alt=&quot;VIP匹配&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有时候，我们需要利用 Maglev 封包将流量重定向到其他的集群中的相同服务，这就有点麻烦了，因为集群间是独立的，我们不知道其它集群相同服务的 VIP。&lt;/p&gt;

&lt;p&gt;VIP 可以通过最长前缀匹配，来决定集群，利用最长后缀匹配决定那个后端池。&lt;/p&gt;

&lt;p&gt;如图中的例子，当请求 173.194.71.1 时，通过最长前缀（173.194.71.0/24）选择 C2 集群，通过最长后缀（0.0.0.1/8）决定是 Service 1 后端池。&lt;/p&gt;

&lt;p&gt;假定 Maglev 需要将流量转发到 C3（173.194.72.0/24），只需要用相同的后缀构造出 VIP （173.194.72.1）进行转发，即可转发到 Maglev 的 Service 1 后端池。&lt;/p&gt;

&lt;h2 id=&quot;分片处理&quot;&gt;分片处理&lt;/h2&gt;

&lt;p&gt;分片时，非首个分片只包含三元组（目的IP地址，目的端口和传输层协议），这便无法正确决定如何转发，因为转发根据的是五元组。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决方法是：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每个 Maglev 配置了一个特殊的后端池，包含所有的 Maglev 机器。&lt;/p&gt;

&lt;p&gt;一旦接收到分片， Maglev 用三元组哈希选择特定的 Maglev 作为后端进行转发，将它们重定向给相同的 Maglev。&lt;/p&gt;

&lt;p&gt;Maglev 为未分片数据包和第二跳的首分片使用相同的后端决策算法，以保证非分片、首个分片和非首个分片选择同一个后端。&lt;/p&gt;

&lt;p&gt;Magelv 维护了一个固定大小的分片表，记录了首分片的转发决策。 当 Maglev 收到一个第二跳非首分片， 会从分片表中查找，若匹配则立即转发； 否则，会缓存到分片表中，直到首分片收到或者老化。&lt;/p&gt;</content><author><name>Simpleyyt</name></author><category term="Network" /><category term="network" /><summary type="html">Google Maglev 是一个牛逼的负载均衡器，之所以牛逼，是因为它不用部署专门的物理设备，不像 LVS 一样工作在内核，它是运行在通用 Linux 服务器上的大型分布式软件系统。</summary></entry><entry><title type="html">Macbook 中毒小记</title><link href="http://localhost:4000/2017/07/01/remove-malware-on-macbook/" rel="alternate" type="text/html" title="Macbook 中毒小记" /><published>2017-07-01T00:00:00-04:00</published><updated>2017-07-01T00:00:00-04:00</updated><id>http://localhost:4000/2017/07/01/remove-malware-on-macbook</id><content type="html" xml:base="http://localhost:4000/2017/07/01/remove-malware-on-macbook/">&lt;p&gt;本以为 macbook 很难中毒的，但是就是发生了，我也很无奈。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;中毒的表现为网页被劫持，老是弹 MacKeeper 的广告，中毒的原因可以是我装了一些流氓软件。&lt;/p&gt;

&lt;p&gt;浏览器时不时地会弹 ssp.zryydi.com 这个网站，本来我以为很好解决，上网搜了一下，都说用 MalwareBytes 扫描一下就好，然而我扫描不出来任何东西，有点慌了。&lt;/p&gt;

&lt;p&gt;我重置了 Safari 和 Chrome，关掉了代理服器，换路由，都没有用，不过频率减小了。因此应该是启动了不该启的进程。&lt;/p&gt;

&lt;p&gt;网上说，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;/Library/LaunchDaemon&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/Library/LaunchAgent&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;~/Library/LaunchAgent&lt;/code&gt;来查找开机启动的流氓软件。找了一通只删掉了名字奇怪的文件，哎，当时就不应该心慈手软，删了之后还是没有起作用。&lt;/p&gt;

&lt;p&gt;正准备重装系统时，我找到了 Adware Removal Pro 这个软件，真是救星，还真的扫出了流氓软件，就是我当时不够狠，没有删的那几个文件，清理之后恢复正常。&lt;/p&gt;</content><author><name>Simpleyyt</name></author><category term="Daily" /><category term="daily" /><summary type="html">本以为 macbook 很难中毒的，但是就是发生了，我也很无奈。</summary></entry><entry><title type="html">Ngnix 是如何解决 epoll 惊群的</title><link href="http://localhost:4000/2017/06/25/how-ngnix-solve-thundering-herd/" rel="alternate" type="text/html" title="Ngnix 是如何解决 epoll 惊群的" /><published>2017-06-25T00:00:00-04:00</published><updated>2017-06-25T00:00:00-04:00</updated><id>http://localhost:4000/2017/06/25/how-ngnix-solve-thundering-herd</id><content type="html" xml:base="http://localhost:4000/2017/06/25/how-ngnix-solve-thundering-herd/">&lt;p&gt;Ngnix 的 master 进程在创建 socket，&lt;code class=&quot;highlighter-rouge&quot;&gt;bind()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;listen()&lt;/code&gt;之后，&lt;code class=&quot;highlighter-rouge&quot;&gt;fork()&lt;/code&gt;出多个 worker，worker 会 将这个 socket 加入 epoll 中，用&lt;code class=&quot;highlighter-rouge&quot;&gt;epoll_wait()&lt;/code&gt;来处理事件，当有一个新的连接来的时候，所有 worker 都会被唤醒，这就是所谓的 epoll 惊群。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;epoll-惊群&quot;&gt;epoll 惊群&lt;/h2&gt;

&lt;p&gt;epoll 有两种工作方式：LT（水平触发） 和 ET（边缘触发）。LT 即只要有事件就通知，而 ET 则只有状态变化时才会通知。&lt;/p&gt;

&lt;p&gt;LT 状态下，只要有通知，所有监听这个 socket 的线程都会被唤醒。&lt;/p&gt;

&lt;p&gt;ET 状态下，内核只会通知一次（一个线程），因此无论是&lt;code class=&quot;highlighter-rouge&quot;&gt;accept()&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;read()&lt;/code&gt;还是&lt;code class=&quot;highlighter-rouge&quot;&gt;write()&lt;/code&gt;都要循环操作到底层返回&lt;code class=&quot;highlighter-rouge&quot;&gt;EAGAIN&lt;/code&gt;为止。&lt;/p&gt;

&lt;p&gt;但是 ET 也会有竞争问题：线程A的&lt;code class=&quot;highlighter-rouge&quot;&gt;epoll_wait()&lt;/code&gt;返回后，线程 A 不断的调用&lt;code class=&quot;highlighter-rouge&quot;&gt;accept()&lt;/code&gt;处理连接请求，当内核的&lt;code class=&quot;highlighter-rouge&quot;&gt;accept queue&lt;/code&gt;队列中的请求恰好处理完时候，内核会重新将该 socket 置为不可读状态，以便可以重新被触发；此时如果新来了一个连接，那么另外一个线程 B 可能被唤醒，然后执行&lt;code class=&quot;highlighter-rouge&quot;&gt;accept()&lt;/code&gt;操作，不过此时之前的线程 A 还需要重新再执行一次&lt;code class=&quot;highlighter-rouge&quot;&gt;accept()&lt;/code&gt;以确认&lt;code class=&quot;highlighter-rouge&quot;&gt;accept queue&lt;/code&gt;已经被处理完了，此时如果线程A成功&lt;code class=&quot;highlighter-rouge&quot;&gt;accept&lt;/code&gt;的话，线程 B 就被惊醒了（线程 B 没有&lt;code class=&quot;highlighter-rouge&quot;&gt;accept&lt;/code&gt;成功）。&lt;/p&gt;

&lt;p&gt;历史上还存在过 accept 惊群，但现在的内核已经解决了这个问题，内核只会唤醒一个进程。&lt;/p&gt;

&lt;h2 id=&quot;ngnix-的解决方法&quot;&gt;Ngnix 的解决方法&lt;/h2&gt;

&lt;p&gt;Ngnix 目前有几种方法解决惊群问题。&lt;/p&gt;

&lt;h3 id=&quot;accept_mutex-锁&quot;&gt;accept_mutex 锁&lt;/h3&gt;

&lt;p&gt;如果开启了&lt;code class=&quot;highlighter-rouge&quot;&gt;accept_mutex&lt;/code&gt;锁，每个 worker 都会先去抢自旋锁，只有抢占成功了，才把 socket 加入到 epoll 中，accept 请求，然后释放锁。&lt;code class=&quot;highlighter-rouge&quot;&gt;accept_mutex&lt;/code&gt;锁也有负载均衡的作用。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;accept_mutex&lt;/code&gt;效率低下，特别是在长连接的时候。因为长连接时，一个进程长时间占用&lt;code class=&quot;highlighter-rouge&quot;&gt;accept_mutex&lt;/code&gt;锁，使得其它进程得不到 accept 的机会。因此不建议使用，默认是关闭的。&lt;/p&gt;

&lt;h3 id=&quot;epollexclusive-标识&quot;&gt;EPOLLEXCLUSIVE 标识&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EPOLLEXCLUSIVE&lt;/code&gt;是4.5+内核新添加的一个 epoll 的标识，Ngnix  在 1.11.3 之后添加了&lt;code class=&quot;highlighter-rouge&quot;&gt;NGX_EXCLUSIVE_EVENT&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EPOLLEXCLUSIVE&lt;/code&gt;标识会保证一个事件发生时候只有一个线程会被唤醒，以避免多侦听下的“惊群”问题。不过任一时候只能有一个工作线程调用 accept，限制了真正并行的吞吐量。&lt;/p&gt;

&lt;h3 id=&quot;so_reuseport-选项&quot;&gt;SO_REUSEPORT 选项&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SO_REUSEPORT&lt;/code&gt; 是惊群最好的解决方法，Ngnix 在 1.9.1 中加入了这个选项，每个 worker 都有自己的 socket，这些 socket 都&lt;code class=&quot;highlighter-rouge&quot;&gt;bind&lt;/code&gt;同一个端口。当新请求到来时，内核根据四元组信息进行负载均衡，非常高效。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;参考：&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://xiaorui.cc/2015/12/02/使用socket-so_reuseport提高服务端性能/&quot;&gt;http://xiaorui.cc/2015/12/02/使用socket-so_reuseport提高服务端性能/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://pureage.info/2015/12/22/thundering-herd.html&quot;&gt;http://pureage.info/2015/12/22/thundering-herd.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/sxhlinux/p/6254396.html&quot;&gt;http://www.cnblogs.com/sxhlinux/p/6254396.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://m.blog.csdn.net/russell_tao/article/details/7204260&quot;&gt;http://m.blog.csdn.net/russell_tao/article/details/7204260&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/51618274?utm_medium=social&amp;amp;utm_source=wechat_session&amp;amp;from=groupmessage&amp;amp;isappinstalled=1&quot;&gt;https://www.zhihu.com/question/51618274?utm_medium=social&amp;amp;utm_source=wechat_session&amp;amp;from=groupmessage&amp;amp;isappinstalled=1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.sohu.com/a/148006569_470018&quot;&gt;http://www.sohu.com/a/148006569_470018&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Simpleyyt</name></author><category term="Network" /><category term="network" /><category term="linux" /><summary type="html">Ngnix 的 master 进程在创建 socket，bind()和listen()之后，fork()出多个 worker，worker 会 将这个 socket 加入 epoll 中，用epoll_wait()来处理事件，当有一个新的连接来的时候，所有 worker 都会被唤醒，这就是所谓的 epoll 惊群。</summary></entry><entry><title type="html">Hello World 的编译链接概述</title><link href="http://localhost:4000/2017/02/12/helloworld-compile-and-link/" rel="alternate" type="text/html" title="Hello World 的编译链接概述" /><published>2017-02-12T00:00:00-05:00</published><updated>2017-02-12T00:00:00-05:00</updated><id>http://localhost:4000/2017/02/12/helloworld-compile-and-link</id><content type="html" xml:base="http://localhost:4000/2017/02/12/helloworld-compile-and-link/">&lt;p&gt;《程序员的自我修养》读书笔记，简单概述一个 Hello World 程序的编译链接过程。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;有如下的&lt;code class=&quot;highlighter-rouge&quot;&gt;hello.c&lt;/code&gt;源文件：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello World&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以用 GCC 来编译运行：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$gcc&lt;/span&gt; hello.c
&lt;span class=&quot;nv&quot;&gt;$.&lt;/span&gt;/a.out
Hello World
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述步骤可以分解为 4 个步骤，分别是&lt;strong&gt;预处理（Prepressing）&lt;/strong&gt;、&lt;strong&gt;编译（Compilation）&lt;/strong&gt;、&lt;strong&gt;汇编（Assembly）&lt;/strong&gt;和&lt;strong&gt;链接（Linking）&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;被隐藏了的过程&quot;&gt;被隐藏了的过程&lt;/h2&gt;

&lt;h3 id=&quot;预处理&quot;&gt;预处理&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$gcc&lt;/span&gt; -E hello.c -o hello.i
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$cpp&lt;/span&gt; hello.c &amp;gt; hello.i
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;预编译过程主要处理那些源代码文件听以“#”开始的预编译指令。&lt;/p&gt;

&lt;p&gt;经过预编译后的 .i 文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到 .i 文件中。&lt;/p&gt;

&lt;h3 id=&quot;编译&quot;&gt;编译&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$gcc&lt;/span&gt; -S hello.i -o hello.S
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者使用&lt;code class=&quot;highlighter-rouge&quot;&gt;cc1&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$/&lt;/span&gt;usr/lib/gcc/i486-linux-gnu/4.1/cc1 hello.c
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;编译过程就是把预处理完的文件进行一系列&lt;strong&gt;词法分析&lt;/strong&gt;、&lt;strong&gt;语法分析&lt;/strong&gt;、&lt;strong&gt;语义分析&lt;/strong&gt;及&lt;strong&gt;优化&lt;/strong&gt;后产生的相应的汇编代码文件。&lt;/p&gt;

&lt;p&gt;实际上 gcc 这个命令只是这些后台程序的包装，它会根据不同的参数要求去调用预编译编译程序 cc1、汇编器 as、链接器 ld。&lt;/p&gt;

&lt;h3 id=&quot;汇编&quot;&gt;汇编&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$as&lt;/span&gt; hello.s -o hello.c
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;或者：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$gcc&lt;/span&gt; -c hello.s -o hello.o
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。&lt;/p&gt;

&lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ld&lt;/span&gt; -static crt1.o crti.o crtbeginT.o hello.o -start-group -lgcc -lgcc_eh -lc -end-group crtend. crtn.o
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;编译器做了什么&quot;&gt;编译器做了什么&lt;/h2&gt;

&lt;p&gt;编译过程一般可以分为6步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。&lt;/p&gt;

&lt;p&gt;以如下代码为例：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;词法分析&quot;&gt;词法分析&lt;/h3&gt;

&lt;p&gt;源代码被输入到&lt;strong&gt;扫描器（Scanner）&lt;/strong&gt;，进行词法分析，生成一系列的&lt;strong&gt;记号（Token）&lt;/strong&gt;。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;记号&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;array&lt;/td&gt;
      &lt;td&gt;标识符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[&lt;/td&gt;
      &lt;td&gt;左方括号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;index&lt;/td&gt;
      &lt;td&gt;标识符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;]&lt;/td&gt;
      &lt;td&gt;右方括号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;=&lt;/td&gt;
      &lt;td&gt;赋值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;(&lt;/td&gt;
      &lt;td&gt;左圆括号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;index&lt;/td&gt;
      &lt;td&gt;标识符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;加号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;)&lt;/td&gt;
      &lt;td&gt;右圆括号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;*&lt;/td&gt;
      &lt;td&gt;乘号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;(&lt;/td&gt;
      &lt;td&gt;左圆括号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;加号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;)&lt;/td&gt;
      &lt;td&gt;右圆括号&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在识别记号的同时，扫描器也将标识符存放到符号表，将数字、字符串常量存放到文字表等。&lt;/p&gt;

&lt;p&gt;有一个叫 lex 的程序可以实现词法分析，它会按照用户之前描述好的词法规则将输入的字符串分割成一个个记号。&lt;/p&gt;

&lt;h3 id=&quot;语法分析&quot;&gt;语法分析&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;语法分析器（Grammar Parser）&lt;/strong&gt;将上述产生的记号进行语法分析，从而生成&lt;strong&gt;语法树（Syntax Tree）&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;有一个现有的工具叫 yacc（Yet Another Compiler Compiler）可以构建出语法树。&lt;/p&gt;

&lt;h3 id=&quot;语义分析&quot;&gt;语义分析&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;语义分析器（Semantic Analyzer）&lt;/strong&gt;完成了对表达式的语法层面的分析，即&lt;strong&gt;静态语义（Static Semantic）&lt;/strong&gt;，包括声明和类型匹配，类型的转换。&lt;/p&gt;

&lt;p&gt;语义分析阶段后，语法树的表达式都被标识了类型，如有隐式转换，则插入相应的转换节点。&lt;/p&gt;

&lt;h3 id=&quot;中间语言的生成&quot;&gt;中间语言的生成&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;源码优化器（Source Code Optimizer）&lt;/strong&gt;将整个语法树转换成&lt;strong&gt;中间代码（Intermediate Code）&lt;/strong&gt;，常见的有&lt;strong&gt;三地址码（Three-address Code）&lt;/strong&gt;和&lt;strong&gt;P-代码（P-Code）&lt;/strong&gt;，再进行源码级别的优化。&lt;/p&gt;

&lt;p&gt;中间代码使用编译器可以被分为前端和后端。编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。&lt;/p&gt;

&lt;h3 id=&quot;目标代码生成与优化&quot;&gt;目标代码生成与优化&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;代码生成（Code Generator）&lt;/strong&gt;将中间代码转换成目标机器代码，&lt;strong&gt;目标代码化化器（Target Code Optimizer）&lt;/strong&gt;则对目标代码进行优化。&lt;/p&gt;

&lt;h2 id=&quot;静态链接&quot;&gt;静态链接&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;链接（Linking）&lt;/strong&gt;的主要内容就是把各个模块之间相互引用的部分都处理好。&lt;/p&gt;

&lt;p&gt;链接过程主要包括了&lt;strong&gt;地址和空间分配（Address and Storage Allocation）&lt;/strong&gt;、&lt;strong&gt;符号决议（Symbol Resolution）&lt;/strong&gt;和&lt;strong&gt;重定位（Relocation）&lt;/strong&gt;这些步骤。&lt;/p&gt;</content><author><name>Simpleyyt</name></author><category term="Program" /><category term="cpp" /><category term="compiler" /><summary type="html">《程序员的自我修养》读书笔记，简单概述一个 Hello World 程序的编译链接过程。</summary></entry><entry><title type="html">彩虹表原理</title><link href="http://localhost:4000/2016/12/24/how-rainbow-table-work/" rel="alternate" type="text/html" title="彩虹表原理" /><published>2016-12-24T00:00:00-05:00</published><updated>2016-12-24T00:00:00-05:00</updated><id>http://localhost:4000/2016/12/24/how-rainbow-table-work</id><content type="html" xml:base="http://localhost:4000/2016/12/24/how-rainbow-table-work/">&lt;p&gt;以前一直以为彩虹表就是一个大的数据库，破解的时候直接通过查表获得明文。今天发现我错了，彩虹表的原理还是挺有趣的。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;如果直接暴力破解 Hash 的明文太费时，如果通过查表的方法则太耗存储。彩虹表则是暴力破解与查表破解的折中。&lt;/p&gt;

&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;假设有这么一个函数&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;，可以将 Hash 值转化与字符串（非明文，而是另一个字符串），称其为衰减函数。假设&lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt;为明文，&lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;为明文的 Hash 值，&lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt;为 Hash 函数。彩虹表在建表时，先选一个&lt;code class=&quot;highlighter-rouge&quot;&gt;p[0]&lt;/code&gt;，做如下计算：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;h[0] = H(p[0])
p[1] = R(h[0])
h[1] = H(p[1])
...
h[k]  = H(p[k])
...
h[n - 1] = H(p[n - 1])
p[n] = R(h[n - 1])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;为迭代的次数。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;经过，这种运算之后，会形成一条 Hash 链：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;p[0]---&amp;gt;h[0]---&amp;gt;p[1]---&amp;gt;...---&amp;gt;p[k]---&amp;gt;h[k]---&amp;gt;...---&amp;gt;p[n]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这条链上已经有&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;对明文到 Hash 值的对应关系了，但我们只保存首尾&lt;code class=&quot;highlighter-rouge&quot;&gt;p[0]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;p[n]&lt;/code&gt;，因为中间的值可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;p[0]&lt;/code&gt;重新通过上述的计算运算出来。&lt;/p&gt;

&lt;p&gt;彩虹表中有好多条这样的链&lt;code class=&quot;highlighter-rouge&quot;&gt; p[0]--&amp;gt;p[n]&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;值取足够大。这样就可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;p[0]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;p[n]&lt;/code&gt;的存储空间，存储&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;对的明文到 Hash 值的对应关系。&lt;/p&gt;

&lt;h2 id=&quot;破解&quot;&gt;破解&lt;/h2&gt;

&lt;p&gt;假设待破解的 Hash 值为&lt;code class=&quot;highlighter-rouge&quot;&gt;h'&lt;/code&gt;，那么我们可以反复地迭代运算 &lt;code class=&quot;highlighter-rouge&quot;&gt;p' = R(h'), h‘= H(p')&lt;/code&gt;，直到&lt;code class=&quot;highlighter-rouge&quot;&gt;p'&lt;/code&gt;与彩虹表中的某个&lt;code class=&quot;highlighter-rouge&quot;&gt;p[n]&lt;/code&gt;相等。&lt;/p&gt;

&lt;p&gt;该链为&lt;code class=&quot;highlighter-rouge&quot;&gt;p[0]--&amp;gt;p[n]&lt;/code&gt;，那么&lt;code class=&quot;highlighter-rouge&quot;&gt;h'&lt;/code&gt;的明文很有可能在这条链中，因为这条链是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;p[0]&lt;/code&gt;反复迭代得到&lt;code class=&quot;highlighter-rouge&quot;&gt;p[n]&lt;/code&gt;的，&lt;code class=&quot;highlighter-rouge&quot;&gt;h'&lt;/code&gt;也是通过反复迭代得到&lt;code class=&quot;highlighter-rouge&quot;&gt;p[n]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我们只要知道&lt;code class=&quot;highlighter-rouge&quot;&gt;h'&lt;/code&gt;迭代到&lt;code class=&quot;highlighter-rouge&quot;&gt;p[n]&lt;/code&gt;的次数，只在找到链中迭代到&lt;code class=&quot;highlighter-rouge&quot;&gt;p[n]&lt;/code&gt;相同次数的&lt;code class=&quot;highlighter-rouge&quot;&gt;h[k]&lt;/code&gt;，就可以获得其明文&lt;code class=&quot;highlighter-rouge&quot;&gt;p[k]&lt;/code&gt;（在链中，&lt;code class=&quot;highlighter-rouge&quot;&gt;h[k] = H(p[k])&lt;/code&gt;）。&lt;/p&gt;</content><author><name>Simpleyyt</name></author><category term="Network" /><category term="network" /><summary type="html">以前一直以为彩虹表就是一个大的数据库，破解的时候直接通过查表获得明文。今天发现我错了，彩虹表的原理还是挺有趣的。</summary></entry><entry><title type="html">支付宝 AR 红包破解</title><link href="http://localhost:4000/2016/12/21/alipay-ar-rb-crack/" rel="alternate" type="text/html" title="支付宝 AR 红包破解" /><published>2016-12-21T00:00:00-05:00</published><updated>2016-12-21T00:00:00-05:00</updated><id>http://localhost:4000/2016/12/21/alipay-ar-rb-crack</id><content type="html" xml:base="http://localhost:4000/2016/12/21/alipay-ar-rb-crack/">&lt;p&gt;网上有好多支付宝的 AR 红包的破解方法，试了一下都不尽人意，所以自己撸了一下简单的。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;破解的想法非常简单：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;遍历每一行，求 RGB 值的方差。&lt;/li&gt;
  &lt;li&gt;如果方差小于某个阈值则该行为小横条，用上面几行替换。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;网上还有好多其他的方法，比如先手工获得小横条位置、识别小横条的灰色，我就不折腾了。&lt;/p&gt;

&lt;p&gt;最后的效果没有那么好，有些识别不出来，亮色点的图片识别率会高一点。我识别出了周围的4个红包，还是挺麻烦的，玩玩就好。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/02683accd59e309d574e9b499edafc7d.js&quot;&gt; &lt;/script&gt;</content><author><name>Simpleyyt</name></author><category term="Daily" /><category term="daily" /><summary type="html">网上有好多支付宝的 AR 红包的破解方法，试了一下都不尽人意，所以自己撸了一下简单的。</summary></entry><entry><title type="html">C++ 函数重载与函数匹配</title><link href="http://localhost:4000/2016/12/17/function-overload-and-match/" rel="alternate" type="text/html" title="C++ 函数重载与函数匹配" /><published>2016-12-17T00:00:00-05:00</published><updated>2016-12-17T00:00:00-05:00</updated><id>http://localhost:4000/2016/12/17/function-overload-and-match</id><content type="html" xml:base="http://localhost:4000/2016/12/17/function-overload-and-match/">&lt;p&gt;《C++ Primer》笔记，整理关于函数重载与函数匹配的笔记。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;函数重载&quot;&gt;函数重载&lt;/h2&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//原函数
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//正确：形参类型不同
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 正确：形参个数不同
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//错误：只有返回类型不同
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//与原函数等价：形参类型相同
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//与原函数等价：顶层 const 将被忽略
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//与原函数等价：只是省略了形参名字
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;函数重载有如下的规则：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;名字相同，形参类型不一样。&lt;/li&gt;
  &lt;li&gt;不允许两个函数除了返回类型外其他所有的要素都相同。&lt;/li&gt;
  &lt;li&gt;顶层&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;的形参无法和没有顶层&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;的形参区分。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中返回类型不同时编译时会出错，而类型别名、项层&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;、省略形参名字只是重复声明而已，只要不定义，编译就不会出错，比如：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//只定义了其中一个
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;函数匹配&quot;&gt;函数匹配&lt;/h2&gt;

&lt;h3 id=&quot;名字查找&quot;&gt;名字查找&lt;/h3&gt;

&lt;p&gt;函数匹配的第一步便是&lt;strong&gt;名字查找（name lookup）&lt;/strong&gt;，确定&lt;strong&gt;候选函数&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;名字查找有两方面：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;常规查找（normal lookup）&lt;/li&gt;
  &lt;li&gt;实参决定的查找（argument-dependent lookup，ADL）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有函数调用都会进行常规查找，只有函数的实参包括类类型对象或指向类类型对象的指针/引用的时候，才会进行实参决定的查找。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常规查找&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//1
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//作用域
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//2
&lt;/span&gt;	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//3
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//候选函数为函数2和3
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//将函数1加入当前作用域
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//候选函数为函数1
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从函数被调用的局部作用域开始，逐渐向上层寻找被调用的名字，一旦找到就停止向上寻找，将找到的所有名字加入候选函数。&lt;/p&gt;

&lt;p&gt;此外，using语句可以将其他作用域的名字引用到当前作用域。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ADL查找&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//1
//第一个实参所在命名空间
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//2
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//3
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//第二个实参的间接父类所在命名空间
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name00&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T00&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//4
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//5
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//第二个实参父类所在命名空间
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T00&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//6
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//7
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//第二个实参所在命名空间
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//8
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//9
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Name1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Name2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//9个函数全是候选函数  
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//第1个函数是normal lookup找到的
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//后8个函数全是argument-dependent lookup找到的
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从第一个类类型参数开始，依次遍历所有类类型参数。对于每一个参数，进入其类型定义所在的作用域（类内友元函数也包括在内），并依次进入其基类、间接基类……定义所在的作用域，查找同名函数，并加入候选函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;在继承体系中上升的过程中，不会因为找到同名函数就停止上升，这不同于常规查找。&lt;/p&gt;

&lt;p&gt;类中的运算符重载也遵循 ADL 查找，其候选函数集既包括成员函数，也应该包括非成员函数。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//1
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//2
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//3
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//1、2、3都是候选函数
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;确定可行函数&quot;&gt;确定可行函数&lt;/h3&gt;

&lt;p&gt;第二步便是从候选函数中选出可行函数，选择的标准如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;形参数量与本次调用提供的实参数量相等&lt;/li&gt;
  &lt;li&gt;每个实参的类型与对应的形参类型相同，或者能转换成形参类型&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//以下为候选函数
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//可行函数
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//可行函数：实参可转化成形参类型
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//可行函数
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//非可行函数：形参数量不匹配
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//非可行函数：实参不能转换成形参
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;寻找最佳匹配&quot;&gt;寻找最佳匹配&lt;/h3&gt;

&lt;p&gt;从可行函数中选择最匹配的函数，如果有多个形参，则最佳匹配条件为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;该函数每个实参的匹配都不劣于其他可行函数需要的匹配。&lt;/li&gt;
  &lt;li&gt;至少有一个实参的匹配优于其他可行函数提供的匹配。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;否则，发生二义性调用错误。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//可行函数
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//二义性错误：double 向 int 的转换与向 float 的转换一样好
&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//调用 void func(int a, int b)
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为了确定最佳匹配，实参类型到形参类型的转换等级如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;精确匹配：
    &lt;ul&gt;
      &lt;li&gt;实参类型和形参类型相同。&lt;/li&gt;
      &lt;li&gt;实参从数组类型或函数类型转换成对应的指针类型。&lt;/li&gt;
      &lt;li&gt;向实参添加顶层&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;或者从实参中删除顶层&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;转换实现的匹配。&lt;/li&gt;
  &lt;li&gt;通过类型提升实现的匹配。&lt;/li&gt;
  &lt;li&gt;通过算术类型转换或指针转换实现的匹配。&lt;/li&gt;
  &lt;li&gt;通过类类型转换实现的匹配。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;一般不会存在这个阶段不会同时存在两个以上的精确匹配，因为两个精确的匹配在本质上是等价的，在定义重载函数时，编译器可能就报出重定义的错误了。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;挑几个重点的来详细说一下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;指针转换实现的匹配&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;0 或&lt;code class=&quot;highlighter-rouge&quot;&gt;nullptr&lt;/code&gt;能转换成任意指针类型。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T *&lt;/code&gt; 能转换成 &lt;code class=&quot;highlighter-rouge&quot;&gt;void *&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;const void *&lt;/code&gt;转换成&lt;code class=&quot;highlighter-rouge&quot;&gt;const void*&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;派生类向基类类型的转换。&lt;/li&gt;
  &lt;li&gt;函数与函数指针的形参类型必须精确匹配。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;类类型转换实现的匹配&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;两个类型提供相同的类型转换将产生二义性问题。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//把一个 B 转换成 A
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 也是把一个 B 转换成 A
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//二义性错误：f(B::operator A()) 还是 f(A::A(const B&amp;amp;))
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//正确：使用 B 的类型转换运算
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//正确：使用 A 的构造函数
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;类当中定义了多个参数都是算术类型的构造函数或类型转换运算符，也会产生二义性问题。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//二义性错误：f(A::operator int()) 还是 f(A::operator double())？
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//二义性错误：A::A(int) 还是 A::A(double)？
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//正确：使用 A::A(int)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配到底是哪个。&lt;/p&gt;</content><author><name>Simpleyyt</name></author><category term="Program" /><category term="cpp" /><summary type="html">《C++ Primer》笔记，整理关于函数重载与函数匹配的笔记。</summary></entry><entry><title type="html">C++ 函数匹配及实参推断</title><link href="http://localhost:4000/2016/11/21/function-matching-and-argument-deduction/" rel="alternate" type="text/html" title="C++ 函数匹配及实参推断" /><published>2016-11-21T00:00:00-05:00</published><updated>2016-11-21T00:00:00-05:00</updated><id>http://localhost:4000/2016/11/21/function-matching-and-argument-deduction</id><content type="html" xml:base="http://localhost:4000/2016/11/21/function-matching-and-argument-deduction/">&lt;p&gt;记录一下函数重载、函数匹配、名字查找与实参类型推断的规则。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;函数重载&quot;&gt;函数重载&lt;/h2&gt;

&lt;h3 id=&quot;函数重载规则&quot;&gt;函数重载规则&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;名字相同，形参类型不一样。&lt;/li&gt;
  &lt;li&gt;不允许两个函数除了返回类型外其他所有的要素都相同。&lt;/li&gt;
  &lt;li&gt;顶层&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;的形参无法和没有顶层&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;的形参区分。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;重载与作用域&quot;&gt;重载与作用域&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;内层作用域中声明的名字，将隐藏外层作用域中声明的同名实体。&lt;/li&gt;
  &lt;li&gt;名字查找发生在类型检查之前。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;名字查找&quot;&gt;名字查找&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;首先，在名字所在的块中寻找其声明语句，只考虑在名字使用之前出现的声明。&lt;/li&gt;
  &lt;li&gt;如果没有找到，继续查找外层作用域。&lt;/li&gt;
  &lt;li&gt;如果最终没有找到匹配的声明，则程序报错。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于类的定义：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先，编译成员的声明。&lt;/li&gt;
  &lt;li&gt;直到类全部可见后才编译函数体。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;函数匹配&quot;&gt;函数匹配&lt;/h2&gt;

&lt;h3 id=&quot;函数匹配步骤&quot;&gt;函数匹配步骤&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;确定候选函数和可行函数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;选择函数名相同的、声明在调用点可见的函数作用候选函数。
在候选函数中选出形参数量匹配并且类型可转换的函数作用可行函数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;寻找最佳匹配&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;从可行函数中选择最匹配的函数，如果有多个形参，则最佳匹配条件为：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;该函数每个实参的匹配都不劣于其他可行函数需要的匹配。&lt;/li&gt;
    &lt;li&gt;至少有一个实参的匹配优于其他可行函数提供的匹配。&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;否则，发生二义性调用错误。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;实参类型转换等级&quot;&gt;实参类型转换等级&lt;/h2&gt;

&lt;p&gt;具体排序如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;精确匹配：
    &lt;ul&gt;
      &lt;li&gt;实参类型和形参类型相同。&lt;/li&gt;
      &lt;li&gt;实参从数组类型或函数类型转换成对应的指针类型。&lt;/li&gt;
      &lt;li&gt;向实参添加顶层&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;或者从实参中删除顶层&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;转换实现的匹配。&lt;/li&gt;
  &lt;li&gt;通过类型提升实现的匹配。&lt;/li&gt;
  &lt;li&gt;通过算术类型转换或指针转换实现的匹配。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;函数指针&quot;&gt;函数指针&lt;/h2&gt;

&lt;p&gt;函数与函数指针的形参类型必须精确匹配。&lt;/p&gt;

&lt;h2 id=&quot;类类型转换运算符匹配&quot;&gt;类类型转换运算符匹配&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;如果类类型和目标类型之间存在多种转换的方式，则可能发生二义性错误：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;两个类型提供相同的类型转换。&lt;/li&gt;
  &lt;li&gt;类定义了多个转换的规则。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配到底是哪个。&lt;/p&gt;

&lt;h2 id=&quot;重载函数与转换构造函数&quot;&gt;重载函数与转换构造函数&lt;/h2&gt;

&lt;p&gt;如果两个或多个类型转换都提供了同一种可行的匹配，则这些类型转换一样好。&lt;/p&gt;

&lt;p&gt;在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性。&lt;/p&gt;

&lt;h2 id=&quot;函数匹配与重载运算符&quot;&gt;函数匹配与重载运算符&lt;/h2&gt;

&lt;p&gt;表达式中运算符的候选函数集既包括成员函数，也应该包括非成员函数。&lt;/p&gt;

&lt;h2 id=&quot;模板实参推断&quot;&gt;模板实参推断&lt;/h2&gt;

&lt;h3 id=&quot;类型转换与模板类型参数&quot;&gt;类型转换与模板类型参数&lt;/h3&gt;

&lt;p&gt;能应用于函数模板的类型转换：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;顶层 const 会被忽略。&lt;/li&gt;
  &lt;li&gt;const 转换：非 const 对象的引用（或指针）传递给一个 const 的引用（或指针）的形参。&lt;/li&gt;
  &lt;li&gt;数组或函数指针的转换。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个模板类型参数可以用作多个函数形参的类型。由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型。&lt;/p&gt;

&lt;p&gt;正常类型转换应用于显示指定的实参。&lt;/p&gt;

&lt;h3 id=&quot;函数指针和实参推断&quot;&gt;函数指针和实参推断&lt;/h3&gt;

&lt;p&gt;当参数是一个函数模板实例的地址时，程序上下文必须満足：对每个模板参数，能唯一确定其类型或值。&lt;/p&gt;

&lt;h3 id=&quot;重载与模板&quot;&gt;重载与模板&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例。&lt;/li&gt;
  &lt;li&gt;候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板。&lt;/li&gt;
  &lt;li&gt;可行函数按类型转换来排序，如果有一个函数比其他函数匹配更好，则选择此函数。&lt;/li&gt;
  &lt;li&gt;如果有多个函数提供同样好的匹配则：
    &lt;ul&gt;
      &lt;li&gt;如果同样好的函数中 且个是非模板函数，则选择此函数。&lt;/li&gt;
      &lt;li&gt;如果没有非模板函数，如果其中一个模板函数更特例化，则选择此模板。&lt;/li&gt;
      &lt;li&gt;否则，此调用有歧义。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;异常类型与-catch-类型的匹配&quot;&gt;异常类型与 catch 类型的匹配&lt;/h2&gt;

&lt;p&gt;异常类型与&lt;code class=&quot;highlighter-rouge&quot;&gt;catch&lt;/code&gt;类型必须精确匹配：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;允许从非常量向常量转换。&lt;/li&gt;
  &lt;li&gt;允许从派生类向基类转换。&lt;/li&gt;
  &lt;li&gt;数组与函数转换成指针。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Simpleyyt</name></author><category term="Program" /><category term="cpp" /><summary type="html">记录一下函数重载、函数匹配、名字查找与实参类型推断的规则。</summary></entry><entry><title type="html">C++ 字面值常量</title><link href="http://localhost:4000/2016/11/14/cpp-literal/" rel="alternate" type="text/html" title="C++ 字面值常量" /><published>2016-11-14T00:00:00-05:00</published><updated>2016-11-14T00:00:00-05:00</updated><id>http://localhost:4000/2016/11/14/cpp-literal</id><content type="html" xml:base="http://localhost:4000/2016/11/14/cpp-literal/">&lt;p&gt;在类型转换和函数匹配中，字面值类型也是非常值得关注的。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;整型和浮点型字面值&quot;&gt;整型和浮点型字面值&lt;/h2&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 十进制 */&lt;/span&gt;	&lt;span class=&quot;mo&quot;&gt;024&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 八进制 */&lt;/span&gt;	&lt;span class=&quot;mh&quot;&gt;0x14&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 十六进制 */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;默认情况下，十进制字面值是带符号数，八进制和十六进制既可能是带符号的也可能是无符号的。&lt;/p&gt;

&lt;p&gt;十进制字面值类型是&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;long long&lt;/code&gt;中尺寸最小的。&lt;/p&gt;

&lt;p&gt;八进制和十六进制字面值类型是&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned int&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned long&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;long long&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned long long&lt;/code&gt;中的尺寸最小者。&lt;/p&gt;

&lt;p&gt;严格来说，十进制字面值不会是负数，负数只是对字面值取负值而已。&lt;/p&gt;

&lt;p&gt;默认的，浮点型字面值是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;转义序列&quot;&gt;转义序列&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\x&lt;/code&gt;后紧跟1个或多个十六进制数字，或&lt;code class=&quot;highlighter-rouge&quot;&gt;\&lt;/code&gt;后紧跟1个、2个或3个八进制数字。&lt;/p&gt;

&lt;h2 id=&quot;指定字面值的类型&quot;&gt;指定字面值的类型&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;前缀&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;u&lt;/td&gt;
      &lt;td&gt;Unicode 16 字符&lt;/td&gt;
      &lt;td&gt;char16_t&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;U&lt;/td&gt;
      &lt;td&gt;Unicode 32 字符&lt;/td&gt;
      &lt;td&gt;char32_t&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;L&lt;/td&gt;
      &lt;td&gt;宽字符&lt;/td&gt;
      &lt;td&gt;wchar_t&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u8&lt;/td&gt;
      &lt;td&gt;UTF-8（仅用于字符串字面常量）&lt;/td&gt;
      &lt;td&gt;char&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;后缀&lt;/th&gt;
      &lt;th&gt;最小匹配类型&lt;/th&gt;
      &lt;th&gt;后缀&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;u or U&lt;/td&gt;
      &lt;td&gt;unsigned&lt;/td&gt;
      &lt;td&gt;f 或 F&lt;/td&gt;
      &lt;td&gt;float&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;l or L&lt;/td&gt;
      &lt;td&gt;long&lt;/td&gt;
      &lt;td&gt;l 或 L&lt;/td&gt;
      &lt;td&gt;long double&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ll or LL&lt;/td&gt;
      &lt;td&gt;long long&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>Simpleyyt</name></author><category term="Program" /><category term="cpp" /><summary type="html">在类型转换和函数匹配中，字面值类型也是非常值得关注的。</summary></entry><entry><title type="html">C++ 类型转换</title><link href="http://localhost:4000/2016/11/13/cpp-type-conversion/" rel="alternate" type="text/html" title="C++ 类型转换" /><published>2016-11-13T00:00:00-05:00</published><updated>2016-11-13T00:00:00-05:00</updated><id>http://localhost:4000/2016/11/13/cpp-type-conversion</id><content type="html" xml:base="http://localhost:4000/2016/11/13/cpp-type-conversion/">&lt;p&gt;C++的类型转换比较杂，看了又忘，再看也忘。在此，总结了一下。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;隐式转换&quot;&gt;隐式转换&lt;/h2&gt;

&lt;h3 id=&quot;何时发生隐式转换&quot;&gt;何时发生隐式转换&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在大多数表达式中，比&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;类型小的整型值首先提升为较大的整数类型（整型提升）。&lt;/li&gt;
  &lt;li&gt;在条件中，非布尔值转换成布尔类型。&lt;/li&gt;
  &lt;li&gt;初始化过程中，初始化值转换成变量类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。&lt;/li&gt;
  &lt;li&gt;如果算术运算或关系运算的运算有多种类型，需要转换成一种类型（算术转换）。&lt;/li&gt;
  &lt;li&gt;函数调用时也会发生类型转换。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;转换规则&quot;&gt;转换规则&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;算术转换&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;运算符的对象转换成最宽的对象。当表达式中既有浮点型也有整型类型时，整型值也转换成浮点型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;整型提升&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;小整数类型转换成较大的整数类型，对于&lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;signed char&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned char&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;short&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned short&lt;/code&gt;，只要它们所有可能的值都能存在&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;里，它们就会提升成&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;类型，否则提升成&lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned int&lt;/code&gt;类型。&lt;/p&gt;

&lt;p&gt;较大的&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;类型（&lt;code class=&quot;highlighter-rouge&quot;&gt;wchar_t&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;char16_t&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;char32_t&lt;/code&gt;）提升成&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned int&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned long&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;long long&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned long long&lt;/code&gt;中最小的一种类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;无符号类型的运算对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先进行整型提升，提升后如果符号相同则小类型转换大类型。如果符号不同，而其中无符号类型不小于带符号类型，则都转成无符号的；如果带符号类型大于无符号类型，如果无符号类型的所有值都能存在带符号类型中，则无符号转成带符号，如果不能，那么带符号转换无符号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;派生类到基类转换&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;派生类型向基类类型转换只对指针或引用有效。&lt;/li&gt;
  &lt;li&gt;基类向派生类不存在隐式类型转换。&lt;/li&gt;
  &lt;li&gt;转换可能访问受限：
    &lt;ul&gt;
      &lt;li&gt;只有公有继承时，用户代码才能使用该转换。&lt;/li&gt;
      &lt;li&gt;任意方式继承，成员函数和友元都能使用该转换。&lt;/li&gt;
      &lt;li&gt;D 公有继承或保存继承 B 时，则 D 的派生类的成员或友元才能使用 B 向 D 的转换。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;能够将一个派生类对象拷贝、移动或赋值给一个基类对象，不过只处理派生类对象的基类部分。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;隐式的类类型转换（转换构造函数）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;能通过一个实参调用的构造函数定义了一条从构造函数的类型向类类型的隐式转换规则，只允许一步类类型转换（内置类型转换除外）。&lt;/p&gt;

&lt;p&gt;可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;explicit&lt;/code&gt;抑制构造函数定义的隐式转换。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其它隐式类型转换&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数组自动转换成指针。&lt;/li&gt;
  &lt;li&gt;指针的转换：&lt;code class=&quot;highlighter-rouge&quot;&gt;nullptr&lt;/code&gt;能转换成任意指针类型；指向任意非常量的指针能转换成&lt;code class=&quot;highlighter-rouge&quot;&gt;void*&lt;/code&gt;；指向任意对象的指针能转换成&lt;code class=&quot;highlighter-rouge&quot;&gt;const void *&lt;/code&gt;；继承关系指针的转换。&lt;/li&gt;
  &lt;li&gt;转换成布尔类型：如果指针或算术类型的值为0，转换结果为&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;；否则转换结果是&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;转换成常量：指向 T 的指针或引用分别转换成指向&lt;code class=&quot;highlighter-rouge&quot;&gt;const T&lt;/code&gt;的指针或引用（顶层&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;）。&lt;/li&gt;
  &lt;li&gt;类类型定义的转换。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;显式转换&quot;&gt;显式转换&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;static_cast&lt;/code&gt;：只要不包含底层&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;，都可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;static_cast&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;const_cast&lt;/code&gt;：只能改变运算对象的底层&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;，如果对象本身是一个常量，那么行为未定义。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;reinterpret_cast&lt;/code&gt;：为运算对象的位模式提供较底层次上的重新解释。&lt;/li&gt;
  &lt;li&gt;旧式强制类型转换：
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  type (expr);
  (type) expr;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Simpleyyt</name></author><category term="Program" /><category term="cpp" /><summary type="html">C++的类型转换比较杂，看了又忘，再看也忘。在此，总结了一下。</summary></entry></feed>