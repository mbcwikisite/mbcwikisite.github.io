<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-09-29T22:35:46+00:00</updated><id>http://localhost:4000/</id><title type="html">MBC-WIKI</title><subtitle>Too simple, sometimes naive.</subtitle><author><name>Simpleyyt</name></author><entry><title type="html">How to send Email with Mailchimp</title><link href="http://localhost:4000/2018/09/29/how-to-send-email-with-mailchimp/" rel="alternate" type="text/html" title="How to send Email with Mailchimp" /><published>2018-09-29T22:28:00+00:00</published><updated>2018-09-29T22:28:00+00:00</updated><id>http://localhost:4000/2018/09/29/how-to-send-email-with-mailchimp</id><content type="html" xml:base="http://localhost:4000/2018/09/29/how-to-send-email-with-mailchimp/">&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus nec leo nibh. Etiam pulvinar viverra ligula vel interdum. Vestibulum ac velit et sapien facilisis viverra. Sed diam justo, fermentum a molestie a, efficitur a neque. Sed dui nunc, rutrum vitae est vitae, lacinia iaculis mauris. Nunc lectus mi, eleifend vitae metus ut, luctus pellentesque mauris. Proin pharetra tempor massa, at feugiat nunc suscipit sed. Donec pulvinar bibendum dictum. In accumsan lorem sem. Suspendisse dictum est et dictum aliquet. In hac habitasse platea dictumst. Nullam iaculis vel eros blandit vulputate.&lt;/p&gt;

&lt;p&gt;Vivamus molestie quam non iaculis dapibus. Cras eleifend lobortis ipsum, at suscipit turpis. Donec ullamcorper mattis hendrerit. Quisque ut lorem dui. Phasellus id ipsum et felis hendrerit fermentum. Aenean interdum sem ut nibh congue, non feugiat quam elementum. Aliquam erat volutpat. Morbi fringilla ipsum libero, eu lacinia urna cursus a. Etiam augue dolor, dapibus eu nisl scelerisque, gravida blandit augue. Nullam pulvinar vel lacus eu aliquet. Pellentesque ex eros, maximus vel fringilla eget, iaculis eu est.&lt;/p&gt;

&lt;p&gt;Vivamus tincidunt, ligula nec consectetur condimentum, ligula ipsum porttitor mi, nec porttitor purus nisi sit amet felis. Cras pretium erat risus. Etiam et ex purus. Fusce quis ultrices erat, vitae dignissim justo. Vestibulum lacinia, felis quis vestibulum porttitor, ante diam sodales leo, vel aliquam dui eros at lectus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum eget dui iaculis, ultricies lorem eget, sodales nulla. Aenean ornare aliquam iaculis. Sed ac lacus tincidunt, suscipit mauris eget, ultricies felis. Ut eu lacinia tortor. Phasellus quis nisi molestie, vulputate diam et, pretium velit. Fusce eget tortor ut augue blandit luctus ut nec ipsum. Suspendisse laoreet massa nisl, sit amet euismod orci commodo quis. Nunc orci metus, mattis nec commodo eget, commodo vel sem.&lt;/p&gt;</content><author><name>Simpleyyt</name></author><category term="mailchimp" /><category term="email" /><summary type="html">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus nec leo nibh. Etiam pulvinar viverra ligula vel interdum. Vestibulum ac velit et sapien facilisis viverra. Sed diam justo, fermentum a molestie a, efficitur a neque. Sed dui nunc, rutrum vitae est vitae, lacinia iaculis mauris. Nunc lectus mi, eleifend vitae metus ut, luctus pellentesque mauris. Proin pharetra tempor massa, at feugiat nunc suscipit sed. Donec pulvinar bibendum dictum. In accumsan lorem sem. Suspendisse dictum est et dictum aliquet. In hac habitasse platea dictumst. Nullam iaculis vel eros blandit vulputate. Vivamus molestie quam non iaculis dapibus. Cras eleifend lobortis ipsum, at suscipit turpis. Donec ullamcorper mattis hendrerit. Quisque ut lorem dui. Phasellus id ipsum et felis hendrerit fermentum. Aenean interdum sem ut nibh congue, non feugiat quam elementum. Aliquam erat volutpat. Morbi fringilla ipsum libero, eu lacinia urna cursus a. Etiam augue dolor, dapibus eu nisl scelerisque, gravida blandit augue. Nullam pulvinar vel lacus eu aliquet. Pellentesque ex eros, maximus vel fringilla eget, iaculis eu est. Vivamus tincidunt, ligula nec consectetur condimentum, ligula ipsum porttitor mi, nec porttitor purus nisi sit amet felis. Cras pretium erat risus. Etiam et ex purus. Fusce quis ultrices erat, vitae dignissim justo. Vestibulum lacinia, felis quis vestibulum porttitor, ante diam sodales leo, vel aliquam dui eros at lectus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum eget dui iaculis, ultricies lorem eget, sodales nulla. Aenean ornare aliquam iaculis. Sed ac lacus tincidunt, suscipit mauris eget, ultricies felis. Ut eu lacinia tortor. Phasellus quis nisi molestie, vulputate diam et, pretium velit. Fusce eget tortor ut augue blandit luctus ut nec ipsum. Suspendisse laoreet massa nisl, sit amet euismod orci commodo quis. Nunc orci metus, mattis nec commodo eget, commodo vel sem.</summary></entry><entry><title type="html">Jekyll Editor 使用入门</title><link href="http://localhost:4000/2015/10/11/jekyll-editor-tutorial/" rel="alternate" type="text/html" title="Jekyll Editor 使用入门" /><published>2015-10-11T00:00:00+00:00</published><updated>2015-10-11T00:00:00+00:00</updated><id>http://localhost:4000/2015/10/11/jekyll-editor-tutorial</id><content type="html" xml:base="http://localhost:4000/2015/10/11/jekyll-editor-tutorial/">&lt;p&gt;Jekyll Editor 专门为 Jekyll 博客定制的强大的 markdown 编辑器，它会自动从&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;yourname&amp;gt;.github.io&lt;/code&gt;仓库读取&lt;code class=&quot;highlighter-rouge&quot;&gt;_post&lt;/code&gt;目录下的博客列表，并可以读取、创建、修改博客。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;项目&quot;&gt;项目&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Github&lt;/strong&gt;：https://github.com/Simpleyyt/jekyll-editor.git&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Chrome 商店&lt;/strong&gt;：https://chrome.google.com/webstore/detail/jekyll-editor/dfdkgbhjmllemfblfoohhehdigokocme&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;主要功能&quot;&gt;主要功能&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;获取博文列表，发布、更新、修改博文&lt;/li&gt;
  &lt;li&gt;博文自动保存到本地&lt;/li&gt;
  &lt;li&gt;强大的 Markdown 编辑器&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;使用说明&quot;&gt;使用说明&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-10-11/10214115.jpg&quot; alt=&quot;Jekyll Editor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;左上角为编辑器的常用工具，包含&lt;code class=&quot;highlighter-rouge&quot;&gt;emoji&lt;/code&gt;表情。右上角的工具依次为登录、全窗口预览、新博文、博文列表、元数据、提交博文，帮助、关于。&lt;/p&gt;

&lt;p&gt;首次使用时，必须先进行登录，也就是与 github 相连。&lt;/p&gt;

&lt;h3 id=&quot;博文列表&quot;&gt;博文列表&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-10-11/12709365.jpg&quot; alt=&quot;博文列表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;博文列表会自动获取&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;yourname.github.io&lt;/code&gt;仓库读取&lt;code class=&quot;highlighter-rouge&quot;&gt;_post&lt;/code&gt;目录下&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;date&amp;gt;-&amp;lt;slug&amp;gt;.md&lt;/code&gt;格式的文件，即为博文。&lt;/p&gt;

&lt;h3 id=&quot;元数据&quot;&gt;元数据&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-10-11/85340312.jpg&quot; alt=&quot;元数据&quot; /&gt;&lt;/p&gt;

&lt;p&gt;即博文的 yaml 格式数据，博文将会以文件名&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;date&amp;gt;-&amp;lt;slug&amp;gt;.md&lt;/code&gt;的格式更新。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：当“发布”打勾时，才会真正地发布。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;已知-bug&quot;&gt;已知 Bug&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;在获取博文列表时，可能会由于多方面原因卡死&lt;/li&gt;
  &lt;li&gt;预览窗口的滚动条有时会出现问题&lt;/li&gt;
  &lt;li&gt;发布时可能会卡死&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Simpleyyt</name></author><category term="daily" /><summary type="html">Jekyll Editor 专门为 Jekyll 博客定制的强大的 markdown 编辑器，它会自动从&amp;lt;yourname&amp;gt;.github.io仓库读取_post目录下的博客列表，并可以读取、创建、修改博客。</summary></entry><entry><title type="html">写 Jekyll 博客工具</title><link href="http://localhost:4000/2015/10/09/tool-for-jekyll-blog/" rel="alternate" type="text/html" title="写 Jekyll 博客工具" /><published>2015-10-09T00:00:00+00:00</published><updated>2015-10-09T00:00:00+00:00</updated><id>http://localhost:4000/2015/10/09/tool-for-jekyll-blog</id><content type="html" xml:base="http://localhost:4000/2015/10/09/tool-for-jekyll-blog/">&lt;p&gt;上次说要写一个类似 stackeditor 的东西来写 Jekyll 博客，终于写好了。这将是第一篇用该工具写的博客。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;详细的说明将会在发布之后再说:smiley:，它是 Chrome App，基于 Editor.md 的一个应用，挺不错的，该有的都有，就是有时候有会 Bug，:disappointed_relieved:。但是没事，我以后会慢慢改进。&lt;/p&gt;

&lt;p&gt;我已经把代码 push 到 github 上去了，项目地址：&lt;a href=&quot;https://github.com/Simpleyyt/jekyll-editor.git&quot;&gt;https://github.com/Simpleyyt/jekyll-editor.git&lt;/a&gt;，写得有点乱，以后再慢慢重构。还有一个重要的问题，我没有 chrome 开发者账号:frowning:，好惨。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-10-9/34912413.jpg&quot; alt=&quot;Jekyll Editor 截图&quot; /&gt;&lt;/p&gt;</content><author><name>Simpleyyt</name></author><category term="daily" /><summary type="html">上次说要写一个类似 stackeditor 的东西来写 Jekyll 博客，终于写好了。这将是第一篇用该工具写的博客。</summary></entry><entry><title type="html">TCP 之保活计时器</title><link href="http://localhost:4000/2015/09/23/tcp-keepalive-timer/" rel="alternate" type="text/html" title="TCP 之保活计时器" /><published>2015-09-23T00:00:00+00:00</published><updated>2015-09-23T00:00:00+00:00</updated><id>http://localhost:4000/2015/09/23/tcp-keepalive-timer</id><content type="html" xml:base="http://localhost:4000/2015/09/23/tcp-keepalive-timer/">&lt;p&gt;保活计时器并不是 TCP 规范中的一部分，是一个有争论的功能。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;如果一个给定的连接在两个小时之内没有任何动作，则服务器就向客户发送一个探查报文段，客户机有如下状态：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;客户机仍正常运行，回复响应。服务器在两小时以后将保活定时器复位。&lt;/li&gt;
    &lt;li&gt;客户机已崩溃，TCP 都没有响应，75秒后超时。服务器总共发10个这样的探查，每个间隔75秒。&lt;/li&gt;
    &lt;li&gt;客户机已重新启动，客户机回复 RST。&lt;/li&gt;
    &lt;li&gt;客户机正常运行，但是服务不可到达，与状态2相同。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;</content><author><name>Simpleyyt</name></author><category term="tcp" /><summary type="html">保活计时器并不是 TCP 规范中的一部分，是一个有争论的功能。</summary></entry><entry><title type="html">字节对齐</title><link href="http://localhost:4000/2015/09/23/data-structure-alignmen/" rel="alternate" type="text/html" title="字节对齐" /><published>2015-09-23T00:00:00+00:00</published><updated>2015-09-23T00:00:00+00:00</updated><id>http://localhost:4000/2015/09/23/data-structure-alignmen</id><content type="html" xml:base="http://localhost:4000/2015/09/23/data-structure-alignmen/">&lt;p&gt;Linux 沿用的对齐策略是，2字节数据类型（例如&lt;code class=&quot;highlighter-rouge&quot;&gt;short&lt;/code&gt;）的地址是2的倍数，而较大的数据类型（例如&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;int*&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;）的地址必须是4的倍数。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Windows 要求任何 K 字节基本对象的址址必须是 K 的倍数，K = 2, 4 或者 8。特别的，它要求一个&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;long long&lt;/code&gt;类型数据的地址应该是8的倍数。&lt;/p&gt;

&lt;h2 id=&quot;对齐准则&quot;&gt;对齐准则&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;四个重要的基本概念：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;数据类型自身的对齐值：char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，double型为8字节。&lt;/li&gt;
    &lt;li&gt;结构体或类的自身对齐值：其成员中自身对齐值最大的那个值。&lt;/li&gt;
    &lt;li&gt;指定对齐值：#pragma pack (value)时的指定对齐值value。&lt;/li&gt;
    &lt;li&gt;数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中，有效对齐值&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;是最终用来决定数据存放地址方式的值。有效对齐&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;表示&lt;strong&gt;“对齐在&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;上”&lt;/strong&gt;，即该数据的&lt;strong&gt;“存放起始地址 % N = 0”&lt;/strong&gt;。而数据结构中的数据变量都是按定义的先后顺序存放。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整(即结构体成员变量占用总长度为结构体有效对齐值的整数倍)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例1：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(strcut A)&lt;/code&gt;值为8；&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(struct B)&lt;/code&gt;的值却是12。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例2：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#pragma pack(2)  //指定按2字节对齐
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#pragma pack()   //取消指定对齐，恢复缺省对齐
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(struct C) = 8&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;栈内存对齐&quot;&gt;栈内存对齐&lt;/h2&gt;

&lt;p&gt;在VC/C++中，栈的对齐方式不受结构体成员对齐选项的影响。总是保持对齐且对齐在4字节边界上。（并未考证64位）&lt;/p&gt;

&lt;h2 id=&quot;位域对齐&quot;&gt;位域对齐&lt;/h2&gt;

&lt;p&gt;位域成员不能单独被取&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;值。下面主要讨论含有位域的结构体的&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;C99 规定&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned int&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt;可以作为位域类型，但编译器几乎都对此作了扩展，允许其它类型的存在。位域作为嵌入式系统中非常常见的一种编程工具，优点在于压缩程序的存储空间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其对齐规则大致为：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;如果相邻位域字段的类型相同，且其位宽之和小于类型的&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；&lt;/li&gt;
    &lt;li&gt;如果相邻位域字段的类型相同，但其位宽之和大于类型的&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；&lt;/li&gt;
    &lt;li&gt;如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6 采取不压缩方式，Dev-C++ 和 GCC 采取压缩方式；&lt;/li&gt;
    &lt;li&gt;如果位域字段之间穿插着非位域字段，则不进行压缩；&lt;/li&gt;
    &lt;li&gt;整个结构体的总大小为最宽基本类型成员大小的整数倍，而位域则按照其最宽类型字节数对齐。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;例3：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element1&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element2&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element3&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;位域类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;，第1个字节仅能容纳下&lt;code class=&quot;highlighter-rouge&quot;&gt;element1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;element2&lt;/code&gt;，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;element1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;element2&lt;/code&gt;被压缩到第1个字节中，而&lt;code class=&quot;highlighter-rouge&quot;&gt;element3&lt;/code&gt;只能从下一个字节开始。因此&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(BitField)&lt;/code&gt;的结果为2。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例4：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StructBitField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element1&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element2&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element3&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;29&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element4&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element5&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stelement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//在含位域的结构或联合中也可同时说明普通成员
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;位域中最宽类型&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;的字节数为4，因此结构体按4字节对齐，在 VC6 中其&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof&lt;/code&gt;为16。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例5：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitField4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element1&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element3&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;长度为0的位域告诉编译器将下一个位域放在一个存储单元的起始位置。如上，编译器会给成员&lt;code class=&quot;highlighter-rouge&quot;&gt;element1&lt;/code&gt;分配3位，接着跳过余下的4位到下一个存储单元，然后给成员&lt;code class=&quot;highlighter-rouge&quot;&gt;element3&lt;/code&gt;分配5位。故上面的结构体大小为2。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;本文参考：&lt;a href=&quot;http://www.cnblogs.com/clover-toeic/p/3853132.html&quot;&gt;http://www.cnblogs.com/clover-toeic/p/3853132.html&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</content><author><name>Simpleyyt</name></author><category term="cpp" /><category term="c" /><summary type="html">Linux 沿用的对齐策略是，2字节数据类型（例如short）的地址是2的倍数，而较大的数据类型（例如int、int*、float和double）的地址必须是4的倍数。</summary></entry><entry><title type="html">位域的大小端问题</title><link href="http://localhost:4000/2015/09/23/bit-endian-little-endian-bit-field/" rel="alternate" type="text/html" title="位域的大小端问题" /><published>2015-09-23T00:00:00+00:00</published><updated>2015-09-23T00:00:00+00:00</updated><id>http://localhost:4000/2015/09/23/bit-endian-little-endian-bit-field</id><content type="html" xml:base="http://localhost:4000/2015/09/23/bit-endian-little-endian-bit-field/">&lt;p&gt;有如下位域结构体：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;strong&gt;小端：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在寄存器中分布如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C11 C10 C9 C8 C7 C6 C5 C4 C3 C2 C1 C0 B15 B14 B13 B12 B11 B10 B9 B8 B7 B6 B5 B4 B3 B2 B1 B0 A3 A2 A1 A0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在内存中存放格式为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0xXXXX0020: B3 B2 B1 B0 A3 A2 A1 A0
0xXXXX0021: B11 B10 B9 B8 B7 B6 B5 B4
0xXXXX0022: C3 C2 C1 C0 B15 B14 B13 B12
0xXXXX0023: C11 C10 C9 C8 C7 C6 C5 C4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;大端：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在寄存器中分布如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A3 A2 A1 A0 B15 B14 B13 B12 B11 B10 B9 B8 B7 B6 B5 B4 B3 B2 B1 B0 C11 C10 C9 C8 C7 C6 C5 C4 C3 C2 C1 C0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在内存中存放如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0xXXXX0020: A3 A2 A1 A0 B15 B14 B13
0xXXXX0021: B11 B10 B9 B8 B7 B6 B5 B4
0xXXXX0022: B3 B2 B1 B0 C11 C10 C9 C8
0xXXXX0023: C7 C6 C5 C4 C3 C2 C1 C0
C11 C10 C9 C8 C7 C6 C5 C4  B15 B14 B13 B12 C3 C2 C1 C0  B11 B10 B9 B8 B7 B6 B5 B4  A3 A2 A1 A0 B3 B2 B1 B0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;本文转自：&lt;a href=&quot;http://blog.sina.com.cn/s/blog_6f611c300102uznw.html&quot;&gt;http://blog.sina.com.cn/s/blog_6f611c300102uznw.html&lt;/a&gt;&lt;/p&gt;</content><author><name>Simpleyyt</name></author><category term="cpp" /><category term="c" /><summary type="html">有如下位域结构体： struct { int a:4; int b:16; int c:12; };</summary></entry><entry><title type="html">TCP 和 UDP 的区别</title><link href="http://localhost:4000/2015/09/22/difference-between-tcp-vs-udp-protocol/" rel="alternate" type="text/html" title="TCP 和 UDP 的区别" /><published>2015-09-22T00:00:00+00:00</published><updated>2015-09-22T00:00:00+00:00</updated><id>http://localhost:4000/2015/09/22/difference-between-tcp-vs-udp-protocol</id><content type="html" xml:base="http://localhost:4000/2015/09/22/difference-between-tcp-vs-udp-protocol/">&lt;ul&gt;
  &lt;li&gt;TCP(Transmission Control Protocol)：传输控制协议&lt;/li&gt;
  &lt;li&gt;UDP(User Datagram Protocol)：用户数据报协议&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主要从连接性(Connectivity)、可靠性(Reliability)、有序性(Ordering)、有界性(Boundary)、拥塞控制(Congestion or Flow control)、传输速度(Speed)、量级(Heavy/Light weight)、头部大小(Header size)等8个方面来讲。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;strong&gt;1. TCP是面向连接(Connection oriented)的协议，UDP是无连接(Connection less)协议；&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TCP用三次握手建立连接：1) Client向server发送SYN；2) Server接收到SYN，回复Client一个SYN-ACK；3) Client接收到SYN_ACK，回复Server一个ACK。到此，连接建成。UDP发送数据前不需要建立连接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2. TCP可靠，UDP不可靠；&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TCP丢包会自动重传，UDP不会。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;3. TCP有序，UDP无序；&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP会对其进行重排序，UDP不会。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;4. TCP无界，UDP有界；&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TCP通过字节流传输，UDP中每一个包都是单独的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;5. TCP有流量控制（拥塞控制），UDP没有；&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;主要靠三次握手实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;6. TCP传输慢，UDP传输快；&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;因为TCP需要建立连接、保证可靠性和有序性，所以比较耗时。这就是为什么视频流、广播电视、在线多媒体游戏等选择使用UDP。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;7. TCP是重量级的，UDP是轻量级的；&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TCP要建立连接、保证可靠性和有序性，就会传输更多的信息，如TCP的包头比较大。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;8. TCP的头部比UDP大；TCP Packet Format Diagram UDP Packet format&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;TCP是面向连接的、可靠的、有序的、速度慢的协议；UDP是无连接的、不可靠的、无序的、速度快的协议。&lt;/li&gt;
    &lt;li&gt;TCP开销比UDP大，TCP头部需要20字节，UDP头部只要8个字节。&lt;/li&gt;
    &lt;li&gt;TCP无界有拥塞控制，TCP有界无拥塞控制。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;补充：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;基于TCP的协议有：HTTP/HTTPS，Telnet，FTP，SMTP。&lt;/li&gt;
    &lt;li&gt;基于UDP的协议有：DHCP，DNS，SNMP，TFTP，BOOTP。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;本文转自：&lt;a href=&quot;http://liangjiabin.com/blog/2015/03/difference-between-tcp-vs-udp-protocol.html&quot;&gt;http://liangjiabin.com/blog/2015/03/difference-between-tcp-vs-udp-protocol.html&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</content><author><name>Simpleyyt</name></author><category term="tcp" /><category term="udp" /><summary type="html">TCP(Transmission Control Protocol)：传输控制协议 UDP(User Datagram Protocol)：用户数据报协议 主要从连接性(Connectivity)、可靠性(Reliability)、有序性(Ordering)、有界性(Boundary)、拥塞控制(Congestion or Flow control)、传输速度(Speed)、量级(Heavy/Light weight)、头部大小(Header size)等8个方面来讲。</summary></entry><entry><title type="html">C++对象模型之复制构造函数</title><link href="http://localhost:4000/2015/09/22/cpp-object-model-copy-constructor/" rel="alternate" type="text/html" title="C++对象模型之复制构造函数" /><published>2015-09-22T00:00:00+00:00</published><updated>2015-09-22T00:00:00+00:00</updated><id>http://localhost:4000/2015/09/22/cpp-object-model-copy-constructor</id><content type="html" xml:base="http://localhost:4000/2015/09/22/cpp-object-model-copy-constructor/">&lt;p&gt;&lt;em&gt;“如果一个 class 未定义出 copy constructor，编译器就自动为它产生出一个”&lt;/em&gt; 这句话是不对的，当 class 展现 &lt;strong&gt;bitwise copy semanics&lt;/strong&gt; 时，编译器才会产生出来。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;如果一个 class 没有提供 explicit copy constructor，把每一个内建的或派生的 data member 的值，从某个 object 拷贝一份到另一个 object 身上，递归方式施行 &lt;strong&gt;memberwise initialization&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ... 没有 explicit copy constructor
&lt;/span&gt;    &lt;span class=&quot;nl&quot;&gt;private:&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有如下调用：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;noun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;book&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;verb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;noun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;则会施行 memberwise initialization：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;verb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;noun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;verb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;noun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;如果一个 String object 被声明为另一个 class 的 member，那么进行 memberwise initialization 时，会递归实施。&lt;/p&gt;

&lt;p&gt;什么时候不展现出 bitwise copy semantics，也就是合成 copy constructor 呢，有4种情况：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;当 member object 存在 copy constructor。&lt;/li&gt;
    &lt;li&gt;当 base class 存在 copy constructor。&lt;/li&gt;
    &lt;li&gt;当 class 声明了 virtual functions 时。&lt;/li&gt;
    &lt;li&gt;当继承链中有 virtual base class 时。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;前面两种情况，在此不做讨论。&lt;/p&gt;

&lt;h2 id=&quot;class-声明了-virtual-functions&quot;&gt;class 声明了 virtual functions&lt;/h2&gt;

&lt;p&gt;这种情况下，可能需要重新设定 Virtual Table 的指针。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ZooAnimal&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ZooAnimal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ZooAnimal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bear&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ZooAnimal&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Bear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有如下使用：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Bear&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yogi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Bear&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;winnie&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yogi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;winnie&lt;/code&gt;会靠 bitwise copy semantics 完成，&lt;code class=&quot;highlighter-rouge&quot;&gt;winnie&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;yogi&lt;/code&gt;都指向&lt;code class=&quot;highlighter-rouge&quot;&gt;Bear class&lt;/code&gt;的 virual table。&lt;/p&gt;

&lt;p&gt;如果是如下使用：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;ZooAnimal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;franny&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yogi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 会发生切割行为
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;franny&lt;/code&gt;的 vptr 不可以被设定指向&lt;code class=&quot;highlighter-rouge&quot;&gt;Bear class&lt;/code&gt;的 virtual table，所以需要重新设定。&lt;/p&gt;

&lt;h2 id=&quot;virtual-base-class-的-subobject&quot;&gt;Virtual Base Class 的 Subobject&lt;/h2&gt;

&lt;p&gt;derived class object 的 virtual base class subobject 位置必须维护，bitwise copy semantics 可能会存坏这个位置。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Raccon&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ZooAnimal&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Raccoon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Raccoon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RedPanda&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Raccoon&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;RedPanda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;RedPanda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果是以下调用：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Raccoon&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rocky&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Raccoon&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;little_critter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rocky&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么 bitwise copy 就可以了。&lt;/p&gt;

&lt;p&gt;如果是：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;RedPanda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;little_red&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Raccoon&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;little_critter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;litter_red&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这时候编译器必须安插代码以设定 virtual base class offset 的初值。&lt;/p&gt;</content><author><name>Simpleyyt</name></author><category term="cpp" /><summary type="html">“如果一个 class 未定义出 copy constructor，编译器就自动为它产生出一个” 这句话是不对的，当 class 展现 bitwise copy semanics 时，编译器才会产生出来。</summary></entry><entry><title type="html">写 Jekyll 博客的正确姿势</title><link href="http://localhost:4000/2015/09/21/tools-for-jekyll/" rel="alternate" type="text/html" title="写 Jekyll 博客的正确姿势" /><published>2015-09-21T00:00:00+00:00</published><updated>2015-09-21T00:00:00+00:00</updated><id>http://localhost:4000/2015/09/21/tools-for-jekyll</id><content type="html" xml:base="http://localhost:4000/2015/09/21/tools-for-jekyll/">&lt;p&gt;用 Jekyll 写博客有个麻烦的地方，就是你可能需要把博客&lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt;下来，修改完成&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;后，再&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;上 GitHub；或者使用 GitHub 的在线编辑器编辑，无论哪种都非常麻烦。幸好找到了几个第三方的写博客和图床工具。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;写博客工具&quot;&gt;写博客工具&lt;/h2&gt;

&lt;p&gt;有两个工具，分别是&lt;code class=&quot;highlighter-rouge&quot;&gt;Jekyll Editor&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;prose.io&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;jekyll-editor&quot;&gt;Jekyll Editor&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-10-11/10214115.jpg&quot; alt=&quot;Jekyll Editor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Jekyll Editor 专门为 Jekyll 博客定制的强大的 markdown 编辑器，它会自动从&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;yourname&amp;gt;.github.io&lt;/code&gt;仓库读取&lt;code class=&quot;highlighter-rouge&quot;&gt;_post&lt;/code&gt;目录下的博客列表，并可以读取、创建、修改博客。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Chrome 商店&lt;/strong&gt;：https://chrome.google.com/webstore/detail/jekyll-editor/dfdkgbhjmllemfblfoohhehdigokocme&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;proseio&quot;&gt;Prose.io&lt;/h3&gt;

&lt;p&gt;非常好的一个工具，它的编辑器非常强大，可以上传图片、文件等，可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;文件中配置&lt;code class=&quot;highlighter-rouge&quot;&gt;prose.io&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-9-21/82332870.jpg&quot; alt=&quot;Prose.io&quot; /&gt;&lt;/p&gt;

&lt;p&gt;缺点就是不支持实时预览，而且也不会自己保存。&lt;/p&gt;

&lt;h2 id=&quot;图床&quot;&gt;图床&lt;/h2&gt;

&lt;p&gt;图床的话强烈推荐&lt;strong&gt;七牛&lt;/strong&gt;，其缺点就是操作不人性化，但是 chrome 上面有好多相关的插件解决这个问题，比如&lt;a href=&quot;http://yotuku.cn/&quot;&gt;极简图床&lt;/a&gt; 便是基于七牛的图床网站。&lt;/p&gt;

&lt;h2 id=&quot;图表工具&quot;&gt;图表工具&lt;/h2&gt;

&lt;p&gt;写博客难免会需要用画一些图表，有两类图表，一类是 &lt;a href=&quot;http://yuml.me/diagram/scruffy/class/draw&quot;&gt;yUML&lt;/a&gt;、&lt;a href=&quot;http://plantuml.com/&quot;&gt;plantUML&lt;/a&gt;, 另一类是 &lt;a href=&quot;http://draw.io&quot;&gt;draw.io&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;yuml-和-plantuml&quot;&gt;yUML 和 plantUML&lt;/h3&gt;

&lt;p&gt;这类图表只需要按格式输入代码，便会自动产生图表，生成图片链接，省去了上传到图床，后期也可以修改。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-9-21/46889912.jpg&quot; alt=&quot;yUML&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-9-21/34152859.jpg&quot; alt=&quot;plantUML&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;drawio&quot;&gt;draw.io&lt;/h3&gt;

&lt;p&gt;这个是在线手动绘图的工具，chrome 应用商店里面也下载得到离线应用，绘图完成之后需要上传到图床中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://simpleyyt.qiniudn.com/15-9-21/68984484.jpg&quot; alt=&quot;draw.io&quot; /&gt;&lt;/p&gt;</content><author><name>Simpleyyt</name></author><category term="jekyll" /><summary type="html">用 Jekyll 写博客有个麻烦的地方，就是你可能需要把博客git pull下来，修改完成commit后，再push上 GitHub；或者使用 GitHub 的在线编辑器编辑，无论哪种都非常麻烦。幸好找到了几个第三方的写博客和图床工具。</summary></entry><entry><title type="html">Blog 新主题</title><link href="http://localhost:4000/2015/09/21/new-blog-theme/" rel="alternate" type="text/html" title="Blog 新主题" /><published>2015-09-21T00:00:00+00:00</published><updated>2015-09-21T00:00:00+00:00</updated><id>http://localhost:4000/2015/09/21/new-blog-theme</id><content type="html" xml:base="http://localhost:4000/2015/09/21/new-blog-theme/">&lt;p&gt;最终把整个 Hexo 的 Jacman 几乎全部移植过来了:smile:，好多 Jekyll 后端不支持的东西都需要前端来解决。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;最近突然想写博客，以前都是用作业部落在记笔记，以后还准备写一个类似 stackeditor 的工具用来写 Jekyll 博客。&lt;/p&gt;

&lt;p&gt;现在已经完美支持语法高亮：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello World&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Simpleyyt</name></author><category term="daily" /><summary type="html">最终把整个 Hexo 的 Jacman 几乎全部移植过来了:smile:，好多 Jekyll 后端不支持的东西都需要前端来解决。</summary></entry></feed>