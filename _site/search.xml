<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title>How to send Email with Mailchimp</title>
      <url>/2018/09/29/how-to-send-email-with-mailchimp/</url>
      <content type="text">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus nec leo nibh. Etiam pulvinar viverra ligula vel interdum. Vestibulum ac velit et sapien facilisis viverra. Sed diam justo, fermentum a molestie a, efficitur a neque. Sed dui nunc, rutrum vitae est vitae, lacinia iaculis mauris. Nunc lectus mi, eleifend vitae metus ut, luctus pellentesque mauris. Proin pharetra tempor massa, at feugiat nunc suscipit sed. Donec pulvinar bibendum dictum. In accumsan lorem sem. Suspendisse dictum est et dictum aliquet. In hac habitasse platea dictumst. Nullam iaculis vel eros blandit vulputate.

Vivamus molestie quam non iaculis dapibus. Cras eleifend lobortis ipsum, at suscipit turpis. Donec ullamcorper mattis hendrerit. Quisque ut lorem dui. Phasellus id ipsum et felis hendrerit fermentum. Aenean interdum sem ut nibh congue, non feugiat quam elementum. Aliquam erat volutpat. Morbi fringilla ipsum libero, eu lacinia urna cursus a. Etiam augue dolor, dapibus eu nisl scelerisque, gravida blandit augue. Nullam pulvinar vel lacus eu aliquet. Pellentesque ex eros, maximus vel fringilla eget, iaculis eu est.

Vivamus tincidunt, ligula nec consectetur condimentum, ligula ipsum porttitor mi, nec porttitor purus nisi sit amet felis. Cras pretium erat risus. Etiam et ex purus. Fusce quis ultrices erat, vitae dignissim justo. Vestibulum lacinia, felis quis vestibulum porttitor, ante diam sodales leo, vel aliquam dui eros at lectus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum eget dui iaculis, ultricies lorem eget, sodales nulla. Aenean ornare aliquam iaculis. Sed ac lacus tincidunt, suscipit mauris eget, ultricies felis. Ut eu lacinia tortor. Phasellus quis nisi molestie, vulputate diam et, pretium velit. Fusce eget tortor ut augue blandit luctus ut nec ipsum. Suspendisse laoreet massa nisl, sit amet euismod orci commodo quis. Nunc orci metus, mattis nec commodo eget, commodo vel sem.
</content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> mailchimp </tag>
        
          <tag> email </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Jekyll Editor 使用入门</title>
      <url>/2015/10/11/jekyll-editor-tutorial/</url>
      <content type="text">Jekyll Editor 专门为 Jekyll 博客定制的强大的 markdown 编辑器，它会自动从&amp;lt;yourname&amp;gt;.github.io仓库读取_post目录下的博客列表，并可以读取、创建、修改博客。



项目


  Github：https://github.com/Simpleyyt/jekyll-editor.git
  Chrome 商店：https://chrome.google.com/webstore/detail/jekyll-editor/dfdkgbhjmllemfblfoohhehdigokocme


主要功能


  获取博文列表，发布、更新、修改博文
  博文自动保存到本地
  强大的 Markdown 编辑器


使用说明



左上角为编辑器的常用工具，包含emoji表情。右上角的工具依次为登录、全窗口预览、新博文、博文列表、元数据、提交博文，帮助、关于。

首次使用时，必须先进行登录，也就是与 github 相连。

博文列表



博文列表会自动获取&amp;lt;yourname.github.io仓库读取_post目录下&amp;lt;date&amp;gt;-&amp;lt;slug&amp;gt;.md格式的文件，即为博文。

元数据



即博文的 yaml 格式数据，博文将会以文件名&amp;lt;date&amp;gt;-&amp;lt;slug&amp;gt;.md的格式更新。

注：当“发布”打勾时，才会真正地发布。

已知 Bug


  在获取博文列表时，可能会由于多方面原因卡死
  预览窗口的滚动条有时会出现问题
  发布时可能会卡死

</content>
      <categories>
        
          <category> Daily </category>
        
      </categories>
      <tags>
        
          <tag> daily </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>写 Jekyll 博客工具</title>
      <url>/2015/10/09/tool-for-jekyll-blog/</url>
      <content type="text">上次说要写一个类似 stackeditor 的东西来写 Jekyll 博客，终于写好了。这将是第一篇用该工具写的博客。



详细的说明将会在发布之后再说:smiley:，它是 Chrome App，基于 Editor.md 的一个应用，挺不错的，该有的都有，就是有时候有会 Bug，:disappointed_relieved:。但是没事，我以后会慢慢改进。

我已经把代码 push 到 github 上去了，项目地址：https://github.com/Simpleyyt/jekyll-editor.git，写得有点乱，以后再慢慢重构。还有一个重要的问题，我没有 chrome 开发者账号:frowning:，好惨。


</content>
      <categories>
        
          <category> Daily </category>
        
      </categories>
      <tags>
        
          <tag> daily </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>TCP 之保活计时器</title>
      <url>/2015/09/23/tcp-keepalive-timer/</url>
      <content type="text">保活计时器并不是 TCP 规范中的一部分，是一个有争论的功能。



如果一个给定的连接在两个小时之内没有任何动作，则服务器就向客户发送一个探查报文段，客户机有如下状态：


  
    客户机仍正常运行，回复响应。服务器在两小时以后将保活定时器复位。
    客户机已崩溃，TCP 都没有响应，75秒后超时。服务器总共发10个这样的探查，每个间隔75秒。
    客户机已重新启动，客户机回复 RST。
    客户机正常运行，但是服务不可到达，与状态2相同。
  

</content>
      <categories>
        
          <category> Network </category>
        
      </categories>
      <tags>
        
          <tag> tcp </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>字节对齐</title>
      <url>/2015/09/23/data-structure-alignmen/</url>
      <content type="text">Linux 沿用的对齐策略是，2字节数据类型（例如short）的地址是2的倍数，而较大的数据类型（例如int、int*、float和double）的地址必须是4的倍数。



Windows 要求任何 K 字节基本对象的址址必须是 K 的倍数，K = 2, 4 或者 8。特别的，它要求一个double或者long long类型数据的地址应该是8的倍数。

对齐准则

四个重要的基本概念：


  
    数据类型自身的对齐值：char型数据自身对齐值为1字节，short型数据为2字节，int/float型为4字节，double型为8字节。
    结构体或类的自身对齐值：其成员中自身对齐值最大的那个值。
    指定对齐值：#pragma pack (value)时的指定对齐值value。
    数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}。
  


其中，有效对齐值N是最终用来决定数据存放地址方式的值。有效对齐N表示“对齐在N上”，即该数据的“存放起始地址 % N = 0”。而数据结构中的数据变量都是按定义的先后顺序存放。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整(即结构体成员变量占用总长度为结构体有效对齐值的整数倍)。

例1：
struct A{
    int    a;
    char   b;
    short  c;
};
struct B{
    char   b;
    int    a;
    short  c;
};



结果：sizeof(strcut A)值为8；sizeof(struct B)的值却是12。

例2：
#pragma pack(2)  //指定按2字节对齐
struct C{
    char  b;
    int   a;
    short c;
};
#pragma pack()   //取消指定对齐，恢复缺省对齐



结果：sizeof(struct C) = 8。

栈内存对齐

在VC/C++中，栈的对齐方式不受结构体成员对齐选项的影响。总是保持对齐且对齐在4字节边界上。（并未考证64位）

位域对齐

位域成员不能单独被取sizeof值。下面主要讨论含有位域的结构体的sizeof。

C99 规定int、unsigned int和bool可以作为位域类型，但编译器几乎都对此作了扩展，允许其它类型的存在。位域作为嵌入式系统中非常常见的一种编程工具，优点在于压缩程序的存储空间。

其对齐规则大致为：


  
    如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；
    如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；
    如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6 采取不压缩方式，Dev-C++ 和 GCC 采取压缩方式；
    如果位域字段之间穿插着非位域字段，则不进行压缩；
    整个结构体的总大小为最宽基本类型成员大小的整数倍，而位域则按照其最宽类型字节数对齐。
  


例3：

struct BitField{
    char element1  : 1;
    char element2  : 4;
    char element3  : 5;
};


位域类型为char，第1个字节仅能容纳下element1和element2，所以element1和element2被压缩到第1个字节中，而element3只能从下一个字节开始。因此sizeof(BitField)的结果为2。

例4：

struct StructBitField{
    int element1   : 1;
    int element2   : 5;
    int element3   : 29;
    int element4   : 6;
    char element5  :2;
    char stelement;  //在含位域的结构或联合中也可同时说明普通成员
};



位域中最宽类型int的字节数为4，因此结构体按4字节对齐，在 VC6 中其sizeof为16。

例5：

struct BitField4{
    char element1  : 3;
    char  :0;
    char element3  : 5;
};



长度为0的位域告诉编译器将下一个位域放在一个存储单元的起始位置。如上，编译器会给成员element1分配3位，接着跳过余下的4位到下一个存储单元，然后给成员element3分配5位。故上面的结构体大小为2。



本文参考：http://www.cnblogs.com/clover-toeic/p/3853132.html
</content>
      <categories>
        
          <category> Program </category>
        
      </categories>
      <tags>
        
          <tag> cpp </tag>
        
          <tag> c </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>位域的大小端问题</title>
      <url>/2015/09/23/bit-endian-little-endian-bit-field/</url>
      <content type="text">有如下位域结构体：

struct {
    int a:4;
    int b:16;
    int c:12;
};





小端：

在寄存器中分布如下：

C11 C10 C9 C8 C7 C6 C5 C4 C3 C2 C1 C0 B15 B14 B13 B12 B11 B10 B9 B8 B7 B6 B5 B4 B3 B2 B1 B0 A3 A2 A1 A0



在内存中存放格式为：

0xXXXX0020: B3 B2 B1 B0 A3 A2 A1 A0
0xXXXX0021: B11 B10 B9 B8 B7 B6 B5 B4
0xXXXX0022: C3 C2 C1 C0 B15 B14 B13 B12
0xXXXX0023: C11 C10 C9 C8 C7 C6 C5 C4



大端：

在寄存器中分布如下：

A3 A2 A1 A0 B15 B14 B13 B12 B11 B10 B9 B8 B7 B6 B5 B4 B3 B2 B1 B0 C11 C10 C9 C8 C7 C6 C5 C4 C3 C2 C1 C0



在内存中存放如下：

0xXXXX0020: A3 A2 A1 A0 B15 B14 B13
0xXXXX0021: B11 B10 B9 B8 B7 B6 B5 B4
0xXXXX0022: B3 B2 B1 B0 C11 C10 C9 C8
0xXXXX0023: C7 C6 C5 C4 C3 C2 C1 C0
C11 C10 C9 C8 C7 C6 C5 C4  B15 B14 B13 B12 C3 C2 C1 C0  B11 B10 B9 B8 B7 B6 B5 B4  A3 A2 A1 A0 B3 B2 B1 B0





本文转自：http://blog.sina.com.cn/s/blog_6f611c300102uznw.html
</content>
      <categories>
        
          <category> Program </category>
        
      </categories>
      <tags>
        
          <tag> cpp </tag>
        
          <tag> c </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>TCP 和 UDP 的区别</title>
      <url>/2015/09/22/difference-between-tcp-vs-udp-protocol/</url>
      <content type="text">
  TCP(Transmission Control Protocol)：传输控制协议
  UDP(User Datagram Protocol)：用户数据报协议


主要从连接性(Connectivity)、可靠性(Reliability)、有序性(Ordering)、有界性(Boundary)、拥塞控制(Congestion or Flow control)、传输速度(Speed)、量级(Heavy/Light weight)、头部大小(Header size)等8个方面来讲。



1. TCP是面向连接(Connection oriented)的协议，UDP是无连接(Connection less)协议；


  TCP用三次握手建立连接：1) Client向server发送SYN；2) Server接收到SYN，回复Client一个SYN-ACK；3) Client接收到SYN_ACK，回复Server一个ACK。到此，连接建成。UDP发送数据前不需要建立连接。


2. TCP可靠，UDP不可靠；


  TCP丢包会自动重传，UDP不会。


3. TCP有序，UDP无序；


  消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP会对其进行重排序，UDP不会。


4. TCP无界，UDP有界；


  TCP通过字节流传输，UDP中每一个包都是单独的。


5. TCP有流量控制（拥塞控制），UDP没有；


  主要靠三次握手实现。


6. TCP传输慢，UDP传输快；


  因为TCP需要建立连接、保证可靠性和有序性，所以比较耗时。这就是为什么视频流、广播电视、在线多媒体游戏等选择使用UDP。


7. TCP是重量级的，UDP是轻量级的；


  TCP要建立连接、保证可靠性和有序性，就会传输更多的信息，如TCP的包头比较大。


8. TCP的头部比UDP大；TCP Packet Format Diagram UDP Packet format

总结：


  
    TCP是面向连接的、可靠的、有序的、速度慢的协议；UDP是无连接的、不可靠的、无序的、速度快的协议。
    TCP开销比UDP大，TCP头部需要20字节，UDP头部只要8个字节。
    TCP无界有拥塞控制，TCP有界无拥塞控制。
  


补充：


  
    基于TCP的协议有：HTTP/HTTPS，Telnet，FTP，SMTP。
    基于UDP的协议有：DHCP，DNS，SNMP，TFTP，BOOTP。
  




本文转自：http://liangjiabin.com/blog/2015/03/difference-between-tcp-vs-udp-protocol.html
</content>
      <categories>
        
          <category> Network </category>
        
      </categories>
      <tags>
        
          <tag> tcp </tag>
        
          <tag> udp </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>C++对象模型之复制构造函数</title>
      <url>/2015/09/22/cpp-object-model-copy-constructor/</url>
      <content type="text">“如果一个 class 未定义出 copy constructor，编译器就自动为它产生出一个” 这句话是不对的，当 class 展现 bitwise copy semanics 时，编译器才会产生出来。



如果一个 class 没有提供 explicit copy constructor，把每一个内建的或派生的 data member 的值，从某个 object 拷贝一份到另一个 object 身上，递归方式施行 memberwise initialization。

例如：

class String {
    public:
        // ... 没有 explicit copy constructor
    private:
        char *str;
        int len;
}



有如下调用：

String noun(&quot;book&quot;);
String verb = noun;



则会施行 memberwise initialization：

verb.str = noun.str;
verb.len = noun.len;


如果一个 String object 被声明为另一个 class 的 member，那么进行 memberwise initialization 时，会递归实施。

什么时候不展现出 bitwise copy semantics，也就是合成 copy constructor 呢，有4种情况：


  
    当 member object 存在 copy constructor。
    当 base class 存在 copy constructor。
    当 class 声明了 virtual functions 时。
    当继承链中有 virtual base class 时。
  


前面两种情况，在此不做讨论。

class 声明了 virtual functions

这种情况下，可能需要重新设定 Virtual Table 的指针。

举个例子：

class ZooAnimal {
public:
    ZooAnimal();
    virtual ~ZooAnimal();
    
    virtual void animate();
    virtual void draw();
};

class Bear : public ZooAnimal {
public:
    Bear();
    void animate();
    void draw();
    virtual void dance();
};



有如下使用：

Bear yogi;
Bear winnie = yogi;



winnie会靠 bitwise copy semantics 完成，winnie和yogi都指向Bear class的 virual table。

如果是如下使用：

ZooAnimal franny = yogi; // 会发生切割行为



franny的 vptr 不可以被设定指向Bear class的 virtual table，所以需要重新设定。

Virtual Base Class 的 Subobject

derived class object 的 virtual base class subobject 位置必须维护，bitwise copy semantics 可能会存坏这个位置。

举个例子：

class Raccon : public virtual ZooAnimal {
public:
    Raccoon() { }
    Raccoon(int val) { }
};

class RedPanda : public Raccoon {
public:
    RedPanda() { }
    RedPanda(int val) { }
};



如果是以下调用：

Raccoon rocky;
Raccoon little_critter = rocky;



那么 bitwise copy 就可以了。

如果是：

RedPanda little_red;
Raccoon little_critter = litter_red;



这时候编译器必须安插代码以设定 virtual base class offset 的初值。
</content>
      <categories>
        
          <category> Program </category>
        
      </categories>
      <tags>
        
          <tag> cpp </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>写 Jekyll 博客的正确姿势</title>
      <url>/2015/09/21/tools-for-jekyll/</url>
      <content type="text">用 Jekyll 写博客有个麻烦的地方，就是你可能需要把博客git pull下来，修改完成commit后，再push上 GitHub；或者使用 GitHub 的在线编辑器编辑，无论哪种都非常麻烦。幸好找到了几个第三方的写博客和图床工具。



写博客工具

有两个工具，分别是Jekyll Editor、prose.io。

Jekyll Editor



Jekyll Editor 专门为 Jekyll 博客定制的强大的 markdown 编辑器，它会自动从&amp;lt;yourname&amp;gt;.github.io仓库读取_post目录下的博客列表，并可以读取、创建、修改博客。


  Chrome 商店：https://chrome.google.com/webstore/detail/jekyll-editor/dfdkgbhjmllemfblfoohhehdigokocme


Prose.io

非常好的一个工具，它的编辑器非常强大，可以上传图片、文件等，可以在_config.yml文件中配置prose.io。



缺点就是不支持实时预览，而且也不会自己保存。

图床

图床的话强烈推荐七牛，其缺点就是操作不人性化，但是 chrome 上面有好多相关的插件解决这个问题，比如极简图床 便是基于七牛的图床网站。

图表工具

写博客难免会需要用画一些图表，有两类图表，一类是 yUML、plantUML, 另一类是 draw.io。

yUML 和 plantUML

这类图表只需要按格式输入代码，便会自动产生图表，生成图片链接，省去了上传到图床，后期也可以修改。





draw.io

这个是在线手动绘图的工具，chrome 应用商店里面也下载得到离线应用，绘图完成之后需要上传到图床中。


</content>
      <categories>
        
          <category> Jekyll </category>
        
      </categories>
      <tags>
        
          <tag> jekyll </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Blog 新主题</title>
      <url>/2015/09/21/new-blog-theme/</url>
      <content type="text">最终把整个 Hexo 的 Jacman 几乎全部移植过来了:smile:，好多 Jekyll 后端不支持的东西都需要前端来解决。



最近突然想写博客，以前都是用作业部落在记笔记，以后还准备写一个类似 stackeditor 的工具用来写 Jekyll 博客。

现在已经完美支持语法高亮：

#include &amp;lt;iostream&amp;gt;
using namespace std;

int main() {
    cout &amp;lt;&amp;lt; &quot;Hello World&quot; &amp;lt;&amp;lt; endl;
    return 0;
}


</content>
      <categories>
        
          <category> Daily </category>
        
      </categories>
      <tags>
        
          <tag> daily </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>C++ 对象模型之构造函数</title>
      <url>/2015/09/21/cpp-object-model-constructor/</url>
      <content type="text">看看以下这段代码：

class Foo { public: int val; Foo *pnext; };

void foo_bar()
{
    Foo bar;
    if (bar.val || bar.pnext )
        // ... do somthing
    // ...
}



上述程序并不会合成出一个 default constructor。什么时候会合成出 default constructor 呢，下面分4种情况。



带有 Default Constructor 的 Memeber Class Object

编译器需要为该 class 合成一个 default constructor，不过这个合成操作只有在 constructor 真正需要被调用时才会发生。

合成的 default constructor、copy constructor、destructor、assignment copy operator 都以inline方式完成，如果函数太复杂，不适合做成inline，就会合成出 explicit non-inline static 实例。

举个例子：

class Foo { public: Foo(); Foot(int ) ... };
class Bar { public: Foo foo; char *str; };

void foo_bar()
{
    Bar bar;
}





编译器会为class Bar合成一个 default constructor 来处理 Bar::foo，但它并不初始化Bar::str。

合成的 default constructor 可能像这样：

inline
Bar::Bar()
{
    foo.Foo::Foo();
}



假设程序员提供了 default constructor：

Bar::Bar() { str = 0; }



则编译器会扩张已存在的 constructors：

Bar::Bar()
{
    foo.Foo::Foo();
    str = 0;
}



如果有多个 class member objects 都要求 constructor 初始化操作，C++ 语言将以 member objects 在 class 中的声明顺序来调用各个 constructors。

带有 Default Constructor 的 Base Class

将会合成 Default Constructor，会根据 base class 声明的顺序调用 base class 的 default constructor。

如果有多个 constructors，编译器会扩张现有的每一个 constructors。

带有一个 Virtual Function 的 Class

以下两种情况，也需要合成出 default constructor：


  
    class 声明（或继承）一个 virtual function。
    class 派生自一个继承串链，其中有一个或更多的 virtual base classes。
  


举个例子：

class Widget {
public:
    virtual void flip() = 0;
    // ...
};

void flip( const Widget&amp;amp; widget ) { widget.flip(); }

void foo()
{
    Bell b;
    Whistle w;
    
    flip(b);
    flip(w);
}





编译期间发生两个扩张：


  
    virtual function table
    pointer member （也就是 vptr ）
  


flip 函数可能被改写如下：

( *widget.vptr[1] )( &amp;amp;widget )



为了让这个机制发挥功效，编译器必须为每一个 Widget（或其派生类）object 的 vptr 设置初值，放置适当的 virtual table 地址。对于 class 所定义的每一个 constructor，编译器会安插一些代码来做这样的事情，如果没有 construcotr，则合成一个。

带有一个 Virtual Base Class 的 Class

例如以下代码：

class X { public: int i; };
class A : public virtual X { public: int j; };
class B : public virtual X { public: double d; };
class C : public A, public B { public: int k; };

void foo(const A* pa) { pa-&amp;gt;i = 1024; }

main()
{
    foo(new A);
    foo(new C);
}


foo()可能被改写如下：

void foo(const A* pa) { pa-&amp;gt;_vbcX-&amp;gt; = 1024; }



class 所定义的每一个 constructor，编译器会安插代码来初始化_vbcX，如果没有 constructors，编译器必须合成一个 default constructor。

总结

C++ 新手一般有两个常见的误解：


  
    任何 class 如果没有定义 default constructor，就会被合成出一个来。
    编译器合成出来的 default constructor 会显式设定 class 内每一个 data member 的默认值。
  


如你所见，没有一个是真的。

</content>
      <categories>
        
          <category> Program </category>
        
      </categories>
      <tags>
        
          <tag> cpp </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>C++ 之迭代器与算法</title>
      <url>/2015/09/21/cpp-iterator-and-algorithm/</url>
      <content type="text">C++ 有插入迭代器、流迭代器、反向迭代器、移动迭代器，泛型算法结构有适用的迭代器类别：输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器。



再探迭代器

迭代器:


  插入迭代器
  流迭代器
  反向迭代器
  移动迭代器


插入迭代器

it = t //在it指定的当前位置插入值t。
*it，++it,it++ //不会做任何事情，都返回it



  back_inserter: push_back的迭代器
  front_inserter: push_front的迭代器
  inserter: 第二个参数指向给定容器的迭代器


流迭代器

istream_iterator&amp;lt;T&amp;gt; in(is); //in从输入流is读取类型为T的值
istream_iterator&amp;lt;T&amp;gt; end;    //读取类型为T的值istream_iterator迭代器，表示尾后位置
in1 == in2  //in1和in2必须读取相同类型
in1 != in2
*in //返回从流中读取的值
in-&amp;gt;mem
++in, in++



ostream_itertor&amp;lt;T&amp;gt; out(os);
ostream_iterator&amp;lt;T&amp;gt; out(os, d); 
out = val
*out, ++out, out++ //不做任何事



可以为任何定义了输入运算符(»)的类型创建istream_iterator对象，类似的(«)可以创建ostream_iterator对象。

反向迭代器


  rbegin、rend、crbegin、crend


反向迭代器需要递减运算符

不可能从一个forward_list或一个流迭代器创建反向迭代器。

泛型算法结构

迭代器类别:


  输入迭代器：== ！= ++ * -&amp;gt; 不保迭代器状态。
  输出迭代器：++ * 只能赋值一次。
  前向迭代器：输入和输出迭代器的操作，多次读写，多遍扫描。
  双向迭代器：前置和后置递减运算符(--)。
  随机访问迭代器：常量时间访问序列，(&amp;lt; &amp;lt;= &amp;gt; &amp;gt;= + += - -= - []）。


算法形参模式

alg(beg, end, other, args);
alg(beg, end, dest, other, args);
alg(beg, end, beg2, other, args);
alg(beg, end, beg2, end2, other, args);




  一些算法使用重载形式传递一个谓词
  _if版本算法
  区分拷贝元素的版本和不拷贝的版本


特定容器算法

链表类型list和forward_list定义了几个成员函数形式的算法：sort merge remove reverse unique。

lst.merge(lst2)
lst.merge(lst2,comp)
lst.remove(val)
lst.remove_if(pred)
lst.reverse()
lst.sort()
lst.sort(comp)
lst.unique()
lst.unique(pred)



splice成员:

lst.splice(args)
lst.splice_after(args)


</content>
      <categories>
        
          <category> Program </category>
        
      </categories>
      <tags>
        
          <tag> cpp </tag>
        
          <tag> c </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>如何使用 Jacman 主题</title>
      <url>/2015/09/20/how-to-use-jacman/</url>
      <content type="text">主题介绍
Jekyll-Jacman 是为 Jekyll 设计的一款清新且具有响应式的主题，拥有更丰富的特性并支持了很多的国内服务。Jacman 始于 Jacman 移植而来。



配置指南

Jacman 主题提供了丰富的配置属性，可以实现您对主题的自定义。配置文件_config.yml位于主题根目录下。本次更新对配置文件进行了较大调整，如您之前就使用了 Jacman，也需要您根据以下指南进行相应的修改。

##### 菜单
menu:
  主页: /
  归档: /archives
  关于: /about

#### 控件
widgets:
- category
- tag
- links
- rss

#### RSS
rss: /atom.xml

#### 图片相关
imglogo:
  enable: true               ## 是否显示网站 logo
  src: img/logo.png        
favicon: img/favicon.ico     ## 网站图标    
apple_icon: img/jacman.jpg   ## 苹果设备上的图标，背景不要透明
author_img: img/author.jpg   ## 网站底部的博主头像
banner_img: img/banner.jpg   ## 博客顶部的图片

close_aside: false      ##是否在文章页面自动关闭侧边栏

#### 首页相关
index:
  expand: true              ## 首页文章是否展开。默认为展开式，显示 Read More。
  excerpt_link: Read More    

#### 作者信息
author:
  name: ## 作者名
  intro_line1:  &quot;Hello ,I'm Larry Page in Google.&quot;    ## 网站底部的个人介绍
  intro_line2:  &quot;This is my blog,believe it or not.&quot;  
  weibo_verifier:  ## 微博秀的验证码
  tsina:           ## 用于微博秀和微博分享
  weibo:           ## 用于显示网站底部社交按钮，下同
  douban:         
  zhihu:  
  email:     
  twitter:   
  github:     
  facebook:
  linkedin:   
  google_plus:   
  stackoverflow:  


#### 目录
toc:
  article: true   ## 是否在文章中显示目录
  aside: true     ## 是否在侧边栏显示目录

#### 友情链接
links:
  码农圈: https://coderq.com,一个面向程序员交流分享的新一代社区
  Jark's Blog: http://wuchong.me

#### 评论
duoshuo_shortname:
disqus_shortname:  

#### 分享按钮
jiathis:
  enable: false   ## 默认使用主题内建分享
  id:    
  tsina:

#### 网站统计
google_analytics:
  enable: false
  id:            ## google analytics ID.
  site:          ## 网站地址.
baidu_tongji:
  enable: false
  sitecode:      ## 百度统计站点特征码
cnzz_tongji:
  enable: false
  siteid:        ## CNZZ统计站点ID

#### 杂项
ShowCustomFont: true  
fancybox: true        
totop: true           

#### 自定义搜索
google_cse:
  enable: false
  cx:  
baidu_search:    
  enable: false
  id:   
  site: http://zhannei.baidu.com/cse/search
tinysou_search:     ## http://tinysou.com/
  enable: false
  id: &quot;4ac092ad8d749fdc6293&quot;



属性功能

  菜单 menu
默认没有启用 /tags 和 /categories页面，如果需要启用请在博客目录下分别建立tags 和 categories文件夹每个文件夹中分别包含一个index.md文件。内容为：


layout: tags (或categories)
title: tags (或categories)
---



      因为主题中已经内置了这两个页面的模板，所以他们会被正确的解析出来。


  控件 widgets
提供了7种小工具。包括标签、分类、RSS、友情链接、微博秀。


友情链接：友情链接的网址添加可以在links属性下添加。

微博秀：需要注意的是，如果要启用微博秀，您必须填上author属性下tsina和weibo_verifier的值，前者是您微博ID，后者是您微博秀的验证码，访问 http://app.weibo.com/tool/weiboshow 在如下图位置，可以获得您的 verifier，如：我的是b3593ceb。


如果要关闭侧边栏，将close_aside置为true，就会在博文页面自动关闭侧边栏。


  
    图片相关 Image
本主题可以设置网站相关图片，例如网站图标（favicon）、网站logo（imglogo）、作者头像（author_img）。建议启用网站logo，格式建议为.svg或.png格式。同时建议提供配套的 favicon 以及在苹果设备上的图标apple_icon（背景不要透明）。
  
  
    首页显示模式 Index
目前首页的显示模式支持两种，一种是原先的卡片式（前往 Demo 预览），另一种是类似官方主题的文章展开式（本站即采用的这种）。两者各有优劣，前者首页加载速度更快，后者文章内容更能吸引读者。主题默认采用后一种展开式，如需开启第一种卡片式，请设置index属性下的expand: false。
  


卡片式的文章摘要是截取文章内容的前140个字，也可以自己总结description并将其放在开头的front-matter中。展开式的文章摘要就是使用&amp;lt;!-- more --&amp;gt;截取了。


  
    作者信息 author
作者信息，建议尽量填写完整。其中tsina是你的新浪微博ID，不同于用户名或微博主页地址。启用这个属性后，其他用户在微博上分享你文章的同时会自动@你。同时它和weibo_verifier一起作用生成微博秀。intro_line1和intro_line2是网站底部的个人介绍。weibo、twitter、facebook等是用来显示网站右下角的社交按钮的，如下图所示。

  
  
    目录 toc
是否启用在文章中或侧边栏中的目录功能。二者可以都为true或都为false。同时，如果你希望在特定的某一篇文章中关闭目录功能你可以在文章文件开头中的front-matter中加上一行toc: false。
  
  
    评论 comments
填写duoshuo_shortname多说的用户名，启用多说评论系统。在大陆地区更好用的评论系统。
  


填写disqus_shortnamedisqus 的用户名，启用 disqus 评论系统。国际上更广泛使用的评论系统。设置博客根目录下的_config.yml文件中的disqus_shortname同样也能开启该功能。


  
    加网分享 jiathis
加网分享系统。默认关闭，因为主题已经内置了原生的分享功能。
  
  
    网站统计 Analytics
google_analytics：Google Analytics追踪代码。请注意：Google Analytics已经升级到了Universal Analytics。请先前往后台升级你的Google Analytics版本后再启用追踪代码，更多信息请点击这里了解。
  


baidu_tongji：百度统计功能。需要填写站点特征码sitecode，在官网注册并配置站点后，获取特征码。特征码可以在「网站中心」-&amp;gt; 「代码获取」中查看，如下图所示的e6d1f421bbc9962127a50488f9ed37d1，注意去掉前面的3F。


cnzz_tongji：站长统计功能。需要填写站点IDsiteid，同理在站长官网注册并配置站点后获得。


  
    数学公式 mathjax
主题支持写 LaTex 数学公式。只需要在文章文件开头的front-matter中，加上一行mathjax: true，即可在文中写 LaTex 公式。
  
  
    图片浏览 fancybox
默认关闭，如果你经常发表 Gallery 类型的文章，那么请设置为true。
  
  
    返回顶部 totop
右下角返回顶部按钮，默认开启。
  
  
    自定义搜索 Search
baidu_search：如果开启百度站内搜索需要登录 百度站内搜索，配置好你的站点，并开启站内搜索获取搜索ID，另外site属性可以填默认值，也可以填自己做了CNAME的二级域名，更详细的可以阅读这篇博客了解。
  


google_cse：如果开启谷歌自定义搜索需要先登录 Google CSE，配置好你的站点，并获得此自定义搜索的ID。此外你需要在博客目录下建立search文件夹并包含一个index.md文件。内容为：
 layout: search
 title: search
 ---



tiny_search: 如果要开启微搜索，需要先注册一个帐号，配置一个Engine，将Engine的Key填入配置文件中的id即可。

常见问题

  
    Q：图片默认都是居左的，我怎么设置能让图片居中呢？

    
      使用 &amp;lt;img src=&quot;&quot; style=&quot;display:block;margin:auto&quot;/&amp;gt;的HTML标签。
    
  
  
    Q：如何建立一篇图片类文章（Gallery Post）？

    
      直接新建一个 Markdown 文件，将其front-matter修改为如下，即可看到主题为图片类文章提供的样式。

      ---
layout: photo
title: Gallery Post
photos:
- http://i.minus.com/ibobbTlfxZgITW.jpg
- http://i.minus.com/iedpg90Y0exFS.jpg
---

      
    
  
  
    Q：我在配置文件中给某一项设置了值，但为什么总是看不到效果啊？

    
      _config.yml文件中的每个属性值前面必须留一个空格，建议在 Sublime/Notepad++ 中开启显示所有空格模式。另每篇文章的 front-matter 也要注意这个问题。
    
  
  
    Q：怎么提意见和建议？

    
      主题还在不断完善中，欢迎 open issue 来提建议，参与讨论。
    
  
  
    Q：为什么我修改了配置文件/发表了博文，解析出来的却是乱码呢？

    
      请将你的配置文件/markdown文件保存成 UTF-8 格式。
    
  
  
    Q：为什么开启了微博秀后，显示是空白的，没有内容展示？

    
      每次修改参数都会这样，需要多刷新几次或者上传到服务器上就好了。
    
  

</content>
      <categories>
        
          <category> Jekyll </category>
        
      </categories>
      <tags>
        
          <tag> jekyll </tag>
        
          <tag> jacman </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>TCP之拥塞处理</title>
      <url>/2015/09/15/tcp-congestion/</url>
      <content type="text">拥塞控制是发送方使用的流量控制，拥塞控制主要有四种算法：慢启动、拥塞避免、快速重传与快速恢复。



慢启动

慢启动为发送方的 TCP 增加了一个窗口：拥塞窗口，记为cwnd，慢启动算法如下：


  连接建好的开始先初始化 cwnd = 1，表明可以传一个 MSS 大小的数据。
  每当收到一个 ACK，cwnd++，这是一种指数增加的关系。
  发送方取拥塞窗口与通告窗口的最小值作为发送上限。


拥塞避免算法

慢启动算法是在一个连接上发起数据流的方法，但有时我们会达到中间路由器的极限，此时分组将被丢弃，拥塞避免算法是一种处理丢失分组的方法，有两种分组丢失的指示：发生超时和接收到重复的确认。

拥塞避免算法和慢启动算法需要地每个连接维持两个变量：一个拥塞窗口 cwnd 和一个慢启动门限 ssthresh，算法如下：


  初始化 cwnd = 1，ssthresh = 65535。
  当拥塞发生时（超时或收到重复确认），ssthreash 设置当前窗口大小的一半（cwnd 和通告窗口大小的最小值，但最小为2个报文）。如果是超时引起的拥塞，则 cwnd 设置为1，进入慢启动过程，否则进入慢速重传与恢复算法。
  cwnd &amp;lt;= ssthresh，进行慢启动；否则正在进行拥塞避免，每次收到一个确认时将 cwnd 增加 1 / cwnd，这是一种加性增长。


快速重传与快速恢复

在收到一个失序的报文段时，TCP 立即需要产生一个重复的 ACK，我们不知道一个重复的 ACK 是不是丢失的报文引起的。如果收到3个或3个以上的重复 ACK，那非常有可能是一个报文段丢失了，快速重传与快速恢复算法如下：


  当收到3个重复的 ACK 时，ssthresh = cwnd / 2，cwnd = sshthresh + 3 * MSS，重传丢失报文段。
  再次收到重复的 ACK 时，cwnd = cwnd + 1。
  如果收到了新的 ACK，cwnd = sshthresh，进入拥塞避免算法。

</content>
      <categories>
        
          <category> Network </category>
        
      </categories>
      <tags>
        
          <tag> tcp </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Linux-ZigBee项目：在Linux上运行6lowpan（一）</title>
      <url>/2014/10/30/6lowpan_on_linux/</url>
      <content type="text">前段时间在看ZigBee的物理层和MAC层协议栈，也就是IEEE802.15.4协议。之后，发现sourceforge上有一个linux-zigbee的项目，中文翻译介绍。虽然这个项目叫Linux-ZigBee，但是因为许可问题除了IEEE802.15.4协议，其它的都没有实现，转而转向6lowpan，所以本文介绍一下用Ubuntu串口连接CC2530运行6lowpan。



#交叉编译内核#

由于主线内核只包含了ieee802154、fakehard和6lowpan，所以没办法使用ZigBee串口设备。所以要下载linux-zigbee内核：

git clone git://git.code.sf.net/p/linux-zigbee/kernel -b 6lowpan linux-zigbee-kernel



当然也可以去项目主页下载。下载完成之后，进行源码目录，然后：

make menuconfig



选择mac802154、ieee802154和serial等模块。然后保存退出，进行编译：

make -j 2



如果出现错误可以网上搜解决方法，编译完成之后，编译模块：

make modules



接着安装模块：

make modules_install



安装内核：

make install



至此，内核已经编译并且安装成功了。重启PC之后，加载相关模块：

sudo modprobe ieee802154
sudo modprobe mac802154
sudo modprobe af_802154
sudo modprobe serial



每当需使用时，都必须加载上述模块。

#安装lowpan-tools#

lowpan-tools是管理Linux LowPAN协议栈的工具，由于Ubuntu的lowpan-tools版本太老了，所以需要从项目主页下载安装：

git clone git://git.code.sf.net/p/linux-zigbee/linux-zigbee linux-zigbee-linux-zigbee



下载完成之后，进入源码目录安装：

./autogen.sh
sudo make install



安装完成之后，便可以使用izattach工具添加ZigBee串口设备。
</content>
      <categories>
        
          <category> Embedded </category>
        
      </categories>
      <tags>
        
          <tag> linux </tag>
        
          <tag> embedded </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>交叉编译OpenWrt上的Helloworld</title>
      <url>/2014/08/11/helloworld_on_openwrt/</url>
      <content type="text">终于编译完成了OpenWrt，并且成功交叉编译了Helloworld，并在Easy-Link的板子上运行。



#编译OpenWrt SDK#

编译OpenWrt的过程，可参考OpenWrt的编译。编译配置我勾选了Advanced configuration option、Build the OpenWrt SDK和Build the OpenWrt based Toolchain。

编译完成之后，交叉编译工具链在类似staging_dir/toolchain-architecture_gcc-compilerver_uClibc-libcver/bin/目录。

#配置环境变量#

主要配置以下环境变量：

PATH=$PATH:(toolchain/bin目录)
export PATH

STAGING_DIR=(toolchain目录)
export STAGING_DIR



#交叉编译Helloopenwrt#

helloopenwrt.c的源码如下：

#include &amp;lt;stdlib.h&amp;gt;

int main() {
    printf(&quot;Hello OpenWrt\n&quot;);
}



然后进行交叉编译：

architecture-openwrt-linux-uclibc-gcc helloopenwrt.c -o helloopenwrt.o



然后将生成的hellowopenwrt.o文件用scp上传到Easy-Link上，并用ssh登录到Easy-Link上，并运行，便可以看到终端输出：

Hello OpenWrt


</content>
      <categories>
        
          <category> Embedded </category>
        
      </categories>
      <tags>
        
          <tag> openwrt </tag>
        
          <tag> embedded </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>OpenWrt编译过程中出现的错误</title>
      <url>/2014/08/11/error_on_compiling_openwrt/</url>
      <content type="text">编译OpenWrt不是件容易的事情，编译过程中要下载包，并且会出现很多奇怪的错误，经过几个小时的编译，终于成功了。



错误的捕获可以通过以下命令：

make V=99



#下载错误#

在编译的过程中，会从网上下载很多源码及包，由于服务器在国外，所以很不稳定，出现下载错误时，你可以多试几次，或者直接下载包放在相应目录。我的解决方法是用代理翻墙到国外下载。

#patch补丁文件错误#

在编译过程中，可能会出现以下的错误：

malformed patch at line xxx



这是由于应用patch 时都会检查受影响的行数是否与记录在两个 @@ 之间的数值一致，如果不一致的话，就要打开patch文件手动修改那个数值以符合受影响的行数。具体可以参考这里。

#Kconfig错误#

在编译时，可能某个Konfig文件出现以下的错误：

'endif' in different file than 'if'
location of the 'if'



这是Kconfig文件出现问题（参考），只要打开相应的Kconfig文件，在他的最后一行加个加车就行了，我也不知道为什么。
</content>
      <categories>
        
          <category> Embedded </category>
        
      </categories>
      <tags>
        
          <tag> openwrt </tag>
        
          <tag> embedded </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>OpenWrt的编译</title>
      <url>/2014/08/10/compile_openwrt/</url>
      <content type="text">最近在淘宝上买了基于AR9331的Easy-Link模块，尝试着编译了一下OpenWrt，编译环境为ubuntu 12.04。



#安装组件#

打开终端，安装编译所需的组件：

sudo apt-get install gcc g++ binutils patch bzip2 flex bison make autoconf gettext texinfo unzip sharutils subversion libncurses5-dev ncurses-term zlib1g-dev git-core gawk asciidoc libz-dev



#下载及更新Openwrt源码#

打开终端，输入下以命令下载源码,当然还可以下载其它的版本，注意不要包含中文路径。

svn co svn://svn.openwrt.org/openwrt/branches/attitude_adjustment



进入源码目录，更新源码：

svn update



更新源：

./scripts/feeds update -a



安装下载好的包：

./scripts/feeds install -a



#编译配置#

打开终端，输入：

make menuconfig



打开OpenWrt配置界面进行配置。当然，Easy-Link有自己的补丁包。

如果你想配置内核，可以在终端中输入：

make kernel_menuconfig



#编译#

在终端中输入：

make -j 2



其中的2表示用2个线程进行编译，适用于多核CPU。在编译过程中会下载相应的文件，编译完成后，会在bin目录生成固件文件。

如果想清除生成的文件，可在终端中输入：

make clean



如果想初始化编译环境，可在终端中输入：

make dirclean



如果想查看编译详细内容，或者捕获错误，可在终端中输入：

make V=99


</content>
      <categories>
        
          <category> Embedded </category>
        
      </categories>
      <tags>
        
          <tag> openwrt </tag>
        
          <tag> embedded </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>VoCore启动成功</title>
      <url>/2014/08/06/first_start_of_vocore/</url>
      <content type="text">换了个VoCore板之后，VoCore就能正常启动了，顺便测试了一下ssh和ap+sta模式。



#SSH连接#

VoCore连上电源后，等待大约30秒之后，便会有发出一个ssid为VoCore的无加密wifi。连上之后，在浏览器输入192.168.1.1，进入Openwrt的Luci界面。



用户名为root，密码为vocore，登录进去之后，系统会提示修改密码并开启ssh，按照提示操作之后，打开终端，输入：

ssh root@192.168.1.1



输入密码之后，便可以登录进去了。

#STA+AP模式#

根据作者博客介绍，VoCore的STA和AP能够同时工作。首先，开启STA模式，添加下面内容到｀/etc/config/network`。

config interface wwan
    option proto 'dhcp'



然后，修改/etc/config/wireless文件：

config wifi-device  radio0
	option type     mac80211
	option channel  11
	option hwmode	11ng
	option path	'10180000.wmac'
	list ht_capab	GF
	list ht_capab	SHORT-GI-20
	list ht_capab	SHORT-GI-40
	list ht_capab	RX-STBC1
	option htmode	HT20

config wifi-iface
    option device   radio0
	option network  lan
	option mode     ap
	option ssid     VoCore
	option encryption none

config wifi-iface
	option device   radio0
	option network  wwan
	option mode     sta
    option ssid     VongerWifi
	option encryption psk2
	option key      PasswordForWifi



修改相应ssid与密码即可。

如果，你家的路由是用192.168.1.1作它的IP地址，那么为避免冲突，你必须修改VoCore的IP，修改文件里相应的IP，如192.168.61.1。

config interface 'lan'
	option ifname 'eth0.1'
	option type 'bridge'
	option proto 'static'
	option ipaddr '192.168.61.1'
	option netmask '255.255.255.0'
	option ip6assign '60'



重启连接成功之后，VoCore便可以访问外网了。
</content>
      <categories>
        
          <category> Embedded </category>
        
      </categories>
      <tags>
        
          <tag> vocore </tag>
        
          <tag> openwrt </tag>
        
          <tag> embedded </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>为Jekyll增加不完美的分页和文章摘要</title>
      <url>/2014/08/04/paginate_and_excerpt_on_jekyll/</url>
      <content type="text">怎么说呢，用Jekyll搭建Blog不管被说的多么好用，但终究应该只属于技术宅+爱折腾的群体吧，经常一个Wordpress上的小功能，却要在Jekyll折腾不少时间，比如之前的站内搜索，以及今天的分页以及文章摘要，足足折腾了我一下午，而且最后的解决方案还是不完美，有点小挫败感。



回到主题，下面先说下Jekyll分页，这个功能有内置的，但是非常见鬼的，只支持对index.html的分页，你没看错，文件名必须是这个，如果你是用JB的话，把index.md重命名成index.html，然后再继续往下看：

修改_config.yml文件，增加

# 每一页显示的文章数
paginate: 5



添加了上面后，你就可以在index.html页面中，引用paginator这个对象了，记住，只有index.html页面可以用。


变量名	                描述
paginator.per_page     每页的文章数
paginator.posts        这个分页下所有的文章列表
paginator.total_posts  总文章数
paginator.total_pages  总页数
paginator.page         当前页
paginator.previous_page前一页
paginator.next_page    后一页


具体如何使用，参考How pagination works.

前面也提到了，这个只支持首页模式，也就是说，你的Blog里有多个文章类目，然后这个是不支持的，所以我称做为不完美的分页。不过我的Blog文章还少，而且我向来是个比较懒的人，等分类下的文章也多了，再来想怎么解决吧。

下面说说怎么搞文章摘要，如果没有摘要的，列表展示是很头大的。目前有这么几种方法：


  
    用内置的truncate或者truncatewords方法，这个好处是内置的，不需要装插件，不需要装插件意味着你可以在托管Github上用，因为Github上很多插件都不支持。但缺点也很明显，对html的标签支持不是很好，如果你是纯文本的Blog，倒也还好。
  
  
    装truncatehtml插件。这个插件首先需要nokogiri，所以你需要在本地安装，安装命令如下：

    gem install nokogiri

    

    然后再安装上述的插件，这个插件的好处就是对解析后的html代码进行控制，但坏处就是，你如果是托管在Github上，那就悲剧了，不能用。
  


上面两种方法，都有一个问题，就是对所有文章的摘要提取都是一样的，但是有时候，对于不同的问题，我想显示不同长度的摘要，所以下面隆重祭出第三种方法（其实，也是我在网上找的，版权不归我哈）： 
首先，在你文章里，想要输出摘要的截至地方，打上标签，比如：

 ---
 title: some post
 layout: post
 ---

 我有一头小毛驴呀，从来也不骑。

 &amp;lt;!--break--&amp;gt;

 有一天我心血来潮骑它取赶集。  



然后用下面的方式截取：

  \{\{ post.content  | | split:'&amp;lt;!--break--&amp;gt;' | first \}\}



这样的方式，就是，你需要在写文章的时候，打一个注释，但是，这个成本，我想，还好吧。



本文转自：http://kingauthur.info/2013/01/20/the-paginator-and-excerpt-in-jekyll/
</content>
      <categories>
        
          <category> Jekyll </category>
        
      </categories>
      <tags>
        
          <tag> jekyll </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>VoCore首次启动失败</title>
      <url>/2014/07/31/failed_on_first_start_of_vocore/</url>
      <content type="text">本来以为首次启动应该顺顺利利的，但是，问题总是在遇到我的时候变得很复杂，问题总是以意思不到的形式出现，接上电源后，竞然搜不到ssid为VoCore的WiFi。



#VoCore的电源#

如图所示，VoCore输入电源3.3V~6.0V，经MT3410L转换成3.3V，再经MT3410L转成1.8V，给RT5350F供电。因此，只要输入5.0V的USB电源便可以正常运行了。



本人决定用Mini USB线来改装。Mini USB有4条线，分别是红、白、绿、蓝（黑），其中红是正极，蓝（黑）是地，将这两根线接到图中红框所示的地方，便可以正常启动。





#问题出现#

接上5V USB电源之后，LED亮了大约1秒，之后，大约隔18秒之后，led亮了大约15秒，之后，又等了好久，始终看不到VoCore的Wifi出现。询问作者Vonger，Vonger表示led正常，要求给出USB-TTL的Log进行分析，所以又制作了VoCore的USB-TTL。

#USB-TTL输出#

依照Vonger博客上的方法，使用USB-TTL模块，并将相应引脚接到红框部分。





电脑端的串口调试客户端，我用的是putty，相关的串口参数如下：


  波特率57600
  数据位8位
  无校验位
  停止位1位


之后，便可以打印出log信息。
</content>
      <categories>
        
          <category> Embedded </category>
        
      </categories>
      <tags>
        
          <tag> vocore </tag>
        
          <tag> openwrt </tag>
        
          <tag> embedded </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>入手VoCore</title>
      <url>/2014/07/30/get_vocore/</url>
      <content type="text">由于项目需要用到RT5350，一个廉价的WiFi片上芯片，在网上搜索相关资料之后，找到了VoCore这个国内的开源项目，一个带用WiFi的硬币大小的Linux计算机。如果感兴趣的话可以了解一下作者的博客和相关介绍。




  #什么是VoCore？#
  VoCore是运行OpenWrt的开源硬件。尽管WIFI, USB, UART, 20+ GPIO一应俱全，但是大小为1英寸（25mm x 25mm）。它提供了很多的接口，比如说10/100M以太网口、USB、UART、I2C、I2S、PCM、JTAG和超过20个的GPIO口。


正如你所看到的，VoCore非常地小，接口也非常密，这个版本没有提代外接的天线，直接用贴片的天线。





以下是它的接口/引脚图，接口非常的丰富，使用必须用电烙铁焊上去。



作者除了本身的博客之外，不提供其它的资料，所示还是先看看他的博客吧。
</content>
      <categories>
        
          <category> Embedded </category>
        
      </categories>
      <tags>
        
          <tag> vocore </tag>
        
          <tag> openwrt </tag>
        
          <tag> embedded </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>在Jekyll上使用分页</title>
      <url>/2014/07/26/pagination_on_jekyll/</url>
      <content type="text">一个博客不可能只有几篇文章，如果所有文章全部放在一个页面中，在文章不多的情况下也许较为直观，一旦文章数量增加，不仅加大了用户需要加载的数据量，也为用户检索文章造成了障碍，所以基本上每个博客都会有文章的分页。一般的分页都是通过像JSP的模板引擎直接在从数据库中分页取出时生成动态生成页面，或者通过ajax从数据库分页取出传递到前端。但现在github+jekyll是静态的页面，没有数据库。好在jekyll支持分页功能。



#开启分页功能#

首先我们需要在jekyll中开启分页功能，在jekyll的_config.yml中加入分页配置：

paginate: 5
paginate_path: &quot;page:num&quot;



第一行定义了每页的文章数量，而第二行则定义了在分页的结果，比如在/index.html中使用分页，定义为page:num，则第二页的路径将是/page2/index.html，第三页的路径将是/page3/index.html，以此类推。

需要注意的几个点：


  分页只在html文件中起作用
  paginate_path同时定义了需要被分页的文件，本人测试这个叫index.html，具体目录由paginate_path中的路径定义，如果定义的目录没有，则会向上寻找index.html，直到根目录的index.html，具体机制官网上没有详细说，所以还需要进一步实验


#使用分页#

只是开启了分页还没有用，我们需要确实使用到首页之中，在首页(/index.html)中添加如下代码：

这样，jekyll就会根据paginator来进行分页了，被分出来多少页，就会有多少个页面生成。排1-5的文章就在/index.html中了，而排6-10的文章则在/page2/index.html中，依次类推。

#换页#

只是分页还不够，我们还需要在每个页面上做一个跳转到其他页面的导航，这里需要用到paginator的一些其他属性。

首先检测总的页数，如果只有一页，自然就不需要分页了。通过paginator的total_pages属性能判断总页数：

{% if paginator.total_pages &amp;gt; 1 %}
&amp;lt;!-- 分页代码 --&amp;gt;
{% endif %}



我们需要一个跳转到上一页的按钮，这个按钮在第一页不需要显示，通过paginator的previous_page属性来判断是否是第一个页面，使用paginator的previous_page_path来输出上一页的路径，注意在前面添加baseurl，并进行一些必要的字符替换：

{% if paginator.previous_page %}
    &amp;lt;a href=&quot;{{ paginator.previous_page_path | prepend: site.baseurl | replace: '//', '/' }}&quot;上一页&amp;lt;/a&amp;gt;
{% endif %}



接着是生成所有页面的按钮，并使当前页按钮无效化，遍历所有页面，使用paginator的page属性来确定当前页，如果是当前页，则按钮无效，否则使用{{ site.paginate_path | prepend: site.baseurl | replace: '//', '/' | replace: ':num', page }}来将:num替换成当前页面的数字生成页面路径：

{% for page in (1..paginator.total_pages) %}
    {% if page == paginator.page %}
      &amp;lt;span class=&quot;active&quot;&amp;gt;{{ page }}&amp;lt;/span&amp;gt;
    {% elsif page == 1 %}
      &amp;lt;a href=&quot;{{ '/index.html' | prepend: site.baseurl | replace: '//', '/' }}&quot;&amp;gt;{{ page }}&amp;lt;/a&amp;gt;
    {% else %}
      &amp;lt;a href=&quot;{{ site.paginate_path | prepend: site.baseurl | replace: '//', '/' | replace: ':num', page }}&quot;&amp;gt;{{ page }}&amp;lt;/a&amp;gt;
    {% endif %}
{% endfor %}



最后生成一个下一页的按钮，在最后一页不显示，和上一页按钮类似，通过paginator的next_page_path来确定是否还有下一页：

{% if paginator.next_page %}
    &amp;lt;a href=&quot;{{ paginator.next_page_path | prepend: site.baseurl | replace: '//', '/' }}&quot;&amp;gt;下一页&amp;lt;/a&amp;gt;
{% endif %}



这样一个完整的分页导航功能就做好了，效果就和博客主页上的分页效果是一样的。

#总结#

jekyll的分页总的来说还算给力，基本的功能可以完成。但是有一些缺陷，就是category，tag的分类分页无法实现，必须通过插件的方式来做。但是github不允许三方插件，所以只能通过一些其他的方式实现了。



本文转自：http://blog.segmentfault.com/skyinlayer/1190000000406015
</content>
      <categories>
        
          <category> Jekyll </category>
        
      </categories>
      <tags>
        
          <tag> jekyll </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Marvell88W8686的SPI主控接口</title>
      <url>/2014/04/20/Marvell88W8686_SPI_Interface/</url>
      <content type="text">88w8686 是一款低成本、低功耗，支持IEEE 802.11a/g/b MAC/基带/射频(RF)无线局域网标准的片上系统,设计支持IEEE 802.11a/g标准的6、
9、12、18、24、36、48、54M 有效数据速率，和IEEE 802.11 b 标准的1、2、5.5、11 M 数据速率。88w8686 提供IEEE802.11/802.11 b 标准直接序列扩散光谱(DSSS),802.11a/ g 正交频分复用(OFDM)基带调制,媒体访问控制(MAC),CPU,内存,主机接口,直接转换收音机,无线局域网射频(RF）功能相结合的单一集成芯片。



88w8686 核心功能单元,通过一个高通量互联系统相互连接，如图所示。



88W8686 配备了一个完全集成的射频到基带收发器工作在2.4 GHz 的ISM 的802.11g/b端口WLAN应用和5 GHz的UNII WLA 802.11a的无线电波段的无线电波段。该收发器架构包括Marvell的第二代，专门设计用于手机通信。蜂窝频段发射杂散音，噪音和接收干扰被设计在其中。

在手机中由于非常低的频谱发射接收频段，设备不会干扰手机接收和发送高
功率移动电话传输信号。为了获得最佳性能，接收路径上集成的LNA 和AGC 增益调整无缝控制基带功能。整个接收路径已超过90 分贝电压增益。

综合发射机正交基带信号转换，然后为2.4 GHz 和5 GHz 无线电频带传输提供外部功率放大器的RF 信号。

本振频率产生一个完全集成的可编程频率合成器，无需任何外部元件。环路
带宽优化相位噪声和动态效能集中在该芯片上。出于安全考虑，88W8686 支持IEEE 802.11i 安全标准，通过实施高级加密标准（AES）/计数器模式CBC - MAC 协议（CCMP），有线等效保密（WEP）临时密钥完整性协议（TKIP）安全机制。为视频，语音，和多媒体应用，88W8686 支持802.11e 的质量服务（QoS）。还支持蓝牙共存接口。88W8686 支持一个通用的SPI（G - SPI）和SDIO 主机接口，采用QFN 封装或倒装芯片封装。

#88W8686 G-SPI主控接口#

88W8686主机接口单元(Host Interface Unit,HIU)连接几个主机接口总线单元到设备(指88W8686)的内部总线上。每个HIU和其他HIU是通过共享到内部总线的连接，但88W8686每次只允许一个HIU被激活。

88W8686的HIU支持G-SPI(通用的SPI)接口和SDIO接口。它支持一个通用的、半双工(half-duplex)、DMA辅助(DMA-assisted)的SPI接口，允许一个主控制器使用通用的SPI协议来访问WLAN设备(指88W8686)。G-SPI接口包含了外部SPI总线和内部共享总线之间的接口电路，如图所示：



88W8686在SPI总线上表示为设备，主机单元能够直接访问G-SPI寄存器和通过使用BARs(Base Address Register，基地址寄存器)和DMA引擎来访问设备的共享内存。

SPI单元支持通用的SPI接口协议，工作速率可达50MHz，此接口支持下面的功能：


  SPI单元总线设备操作
  SPI单元寄存器读写
  对内部CPU产生中断
  对外部SPI主控制器产生中断(比如S3C2451的SPI控制器)
  通过DMA访问内部共享内存
  对电源管理单元产生唤醒中断


G-SPI接口信号描述

88W8686复位后，紧接着使用下面配置输入引脚来设置参数，但是在88W8686复位到一定时间之后，这些引脚立刻改为变他们通常的功能，比如GPIO[5]就作为通常的功能使用。如果要设置一个配置位为0，通过连接一个阻值为100 kΩ的下拉电阻，比如：



如果要设置一个配置位为1，则不需要接外部电路



88W8686的配置引脚如下图所示：



接下来看G-SPI接口引脚的说明：



#G-SPI接口功能描述#

G-SPI接口的标准G-SPI物理总线上支持多种简单的地址/数据协议，这些协议通过地址的位数和数据的顺序来区分。

每次通讯由主机通过拉低SCSn信号来发起，从机在检测到SCSn有效(低电平)之后，在每个SCLK的上升沿锁存SDI引脚上输入的数据。当从机要输出数据时，在SCLK的下降沿送出数据。SCLK输入信号在每次通讯的开始和结束都为低电平，中断输入信号SINTn由设备发送给主机(比如S3C2451的SPI主控制器)

##通讯时延(transaction delay)##

第一个数据块是从主机发送到设备(从机)的，这个数据块包含一个地址和读/写标志，地址的最高位(MSB)如果为0表示读，如果为1表示写。


  写操作时延(write Write Transaction Delay)
    
      对于写操作，写操作的数据段紧跟着地址段，地址和数据段之间，不需要主机产生低时钟脉冲。
    
  
  
    读操作时延(read Write Transaction Delay)

    
      读操作时，在总线上地址段之后和数据段之前要求有一些时延。这些时延表现为TDDR(time delay read register，读寄存器时延)和TDRP(timedelay read port，读端口时延)，这些时延表示设备需要需要一些时间来准备有效数据给主机。
    
  


有两种方式来建立这些时延：


  第一种：主机通过发送一定数量的虚拟时钟周期(a known number of dummyclock cycles)到设备来创建读操作时延，这些虚拟时钟周期定义在延迟读寄存器(delay readregister)中，也就是说主机要发送的虚拟时钟周期数量由延迟读寄存器的值来定，下面来看此寄存器的定义：




由上图可知Delay Method的值由SPU Bus Mode寄存器(offset 0x70[2]=1)的Delay_Method位的值来决定，下面来看此寄存器的定义：



SPU(SPI host interface unit)表示SPI主机接口单元。


  第二种：通过主机在地址段和数据段之间保持(holding)低时钟信号至少一段时间来创建读操作时延(the delay is created bythe host holding the clock signal low for a minimum period of time between the addressand data phases)，此模式通过设置0x70[2]=0来选择。


在读操作的数据段区间，主机继续提供时钟脉冲和同时驱动数据到SDI输入引脚或从SDO输出引脚读取数据。

##数据传输##

主机经常访问G-SPI单元的配置寄存器，为了访问内部内存空间，一些寄存器被定义为端口寄存器。当访问端口寄存器时，从机使用相应的基地址寄存器(BAR)和DMA引擎来从内部内存空间读取数据，或是写入数据内部内存空间。

主机和从机间的每一次传输都是突发模式(一个地址后面跟着多个数据)，在读或写完所要求数量的数据后，主机通过拉高SCSn引脚来结束此次传输。

###端口寄存器访问####

主机读端口寄存器时，对于突发模式的数据长度没有限制(除了内部总线的有效地址范围限制之外)。主机写端口寄存器时，对突发模式的数据长度唯一要求是：长度是DWORDS的倍数。

端口寄存器(I/O端口，命令端口，数据端口)被用来访问内部32-bit存储空间和总是32-bit对齐访问。每个端口寄存器都有一个相应的BAR用来读写(BAR作为一个指针指向要读写的内存空间的开始物理地址)。内存也只能32-bit对齐访问，这通过向相应的BAR写入32-bit对齐的数据来是实现，在访问期间，第16bits数据总线最先出现在总线上。


  
    写数据到端口寄存器

    
      写数据到端口寄存器，就是依次填满起始位置在BAR的连续的32-bit内存空间。当从从机的数据和命令端口读数据时，DMA引擎连续填充FIFO知道剩余空间不足8个DWORDs。当写数据到设备时，拉高SCSn信号脚来清空FIFO。
    
  
  
    从端口寄存器读数据

    
      当从设备的I/O端口读数据时，可以选择DMA引擎是执行单一读或是突发模式读。突发模式读与读端口和命令端口一样，单一模式读让DMA引擎在内部总线上指向单个DWORD访问。单一模式读通讯必须在返回数据的第一或是第二个16-bit块之后终止。
    
  


###配置寄存器访问###

当主机访问端口寄存器之外的其他寄存器时，突发模式长度必须限制在一个16-bit的数，或是如果地址是以DWORD边界对齐的两个16-bit数。当内部总线的单元访问G-SPI接口寄存器，则必须是单个DWORD或是更小来访问。

G-SPI除了端口寄存器之外的接口寄存器，都能以16-bit边界对齐的方式读或是写。当单个16-bit word被读出或写入，通讯可以被终止。

##G-SI时钟频率##

G-SPI时钟频率不能大于内部总线时钟频率的2.5倍，内部总线时钟频率



##数据格式##

总共有16个有效数据格式，下面9个数据格式是可用的：


  所有4读数据格式，在地址段和数据段之间的延迟时间，时钟信号保持为低电平。
  所有4个写数据格式。
  1个读数据格式，在地址段和数据段之间的延迟时间，时钟信号切换为固定数量的周期。


每种读写操作类型都有两种地址长度，要么是8-bit要么是16-bit，而每种地址长度对应有两种数据顺序。

###可编程的时钟周期延迟###

下面是Delay_Method=0的读数据格式，在这种模式下，tdr(r/p)的值代表最后一个地址位和第一个数据位之间的延时时间，这段时间内时钟信号SCLK保持为低电平。有两个不同的延时值，包括从G-SPI配置寄存器读取的值和从G-SPI端口寄存器读取的值。一旦读写操作指定的时延期满，有效的数据就从设备中发出。


  
    读数据格式

    
  
  
    写数据格式

    
  


###固定的时钟周期延迟###

下面是读数据格式的例子：



目前我们G-SPI驱动读数据格式就是采用这种格式。

##G-SPI接口寄存器内存空间##





本文章转自：http://blog.csdn.net/loongembedded/article/details/9067013
</content>
      <categories>
        
          <category> Embedded </category>
        
      </categories>
      <tags>
        
          <tag> embedded </tag>
        
          <tag> 88w8686 </tag>
        
          <tag> wifi </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>批量删除Kindle云端的个人文档</title>
      <url>/2014/04/18/delete_document_on_kindle_cloud/</url>
      <content type="text">在使用Kindle的推送时，有一个不好的地方就是，推送的电子书会被放到云端，而且要删除的话不能批量删，长年累月就积累了一大批。本人找到一种方法可以批量删除当前个人文档页面的电子书。



首先，登录amazon，并点击个人文档，将以下代码复制进地址栏中：

javascript:(function(){ var v = new RegExp(&quot;PersonalDocuments&quot;); if (!v.test(document.URL)) { return false; } {a=document.getElementsByClassName('rowBodyCollapsed');for(var i = 0; i&amp;lt;a.length; i++){Fion.deleteItem('deleteItem_'+a[i].getAttribute('asin'));};return; }})();



按回车后，便会删除当前页面的电子书。当然，你也可以在搜索框搜索电子书，再输入以上代码删除搜索结果页面的电子书。

这里有一个要注意的地方，如果你使用的浏览器是chrome的话，以上代码复制进地址栏时，javascript这个关键字会被注释掉，可以复制进地址栏之后，再在前面添加javascript关键字。当然，你也可以按F12进入打开开发者工具，再点击Console,再输入以上代码。
</content>
      <categories>
        
          <category> Daily </category>
        
      </categories>
      <tags>
        
          <tag> kindle </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>sk_buff结构分析</title>
      <url>/2014/04/16/sk_buff_analysis/</url>
      <content type="text">在wlan驱动中，数据读取写入是通过sk_buff这个结构体，而sk_buff结构主要作用是包含接收的缓冲数据，和它的包头信息。



如下是sk_buff的主要结构成员：

struct sk_buff {
...
	unsigned char *head;
	unsigned char *data;
	unsigned char *tail;
	unsigned char *end;
...
};



当然，sk_buff还包含一些链表的东西，在此处并不做解析。在以上结构体中：


  head：报文缓冲区的头；
  data：数据的头指针；
  tail：数据的尾指针；
  end ：报文缓冲区的尾部。


如图所示，



分别有三个空间：head room、packet data、tail room。其中packet data是数据所在区包括数据的包头，head room是数据头部增长的预留空间、tail room是尾部增加的空间。预留头部使用skb_reserve(skb, header_len);函数，尾部增加使用skb_put()，头部增长使用skb_push()。

以下图是调用分配空间函数，即初始化函数alloc_skb(len, GFP_KERNEL)的样子：



可以看到，head、data和tail都指向了缓冲区的起始，而end指向结束。这个SKB的数据长度为0，不包含任何数据。

接着调用了skb_reserve(skb, header_len)预留了头部数据，如图所示：



通过调用skb_put()向尾部增长数据，如图所示：



通过调用skb_push()向头部增长数据，如图所示，增加了一个UDP头：





本文考参：http://vger.kernel.org/~davem/skb_data.html
</content>
      <categories>
        
          <category> Linux </category>
        
      </categories>
      <tags>
        
          <tag> linux </tag>
        
          <tag> driver </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>QF9700 Linux 3.0.8驱动补丁</title>
      <url>/2014/04/15/qf9700_for_linux_3.0.8/</url>
      <content type="text">网上有QF9700/RD9700的开源驱动，点此下载。但是最高只支持Linux 2.6.32，在Linux 3.0.8编译下会出现错误，如下：



Building QF9700 USB2NET chip driver...
make[1]: 正在进入目录 `/home/snail/文档/Project/FriendlyArm/linux-3.0.8'
  CC [M]  /home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.o
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c: In function 'qf9700_set_multicast':
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c:356:45: error: 'struct net_device' has no member named 'mc_count'
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c:358:16: error: 'struct net_device' has no member named 'mc_count'
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c:359:36: error: 'struct net_device' has no member named 'mc_list'
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c:362:22: error: 'struct net_device' has no member named 'mc_count'
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c:362:56: error: dereferencing pointer to incomplete type
/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.c:363:14: error: dereferencing pointer to incomplete type
make[2]: *** [/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700/qf9700.o] 错误 1
make[1]: *** [_module_/home/snail/文档/Project/FriendlyArm/qf9700-2.6.32/qf9700] 错误 2
make[1]:正在离开目录 `/home/snail/文档/Project/FriendlyArm/linux-3.0.8'
make: *** [all] 错误 2



为此，写了一个补丁。

diff -ur b/qf9700.c a/qf9700.c
--- b/qf9700.c	2011-01-21 17:59:58.000000000 +0800
+++ a/qf9700.c	2014-04-15 18:37:50.000000000 +0800
@@ -353,14 +353,13 @@
 
 	if (net-&amp;gt;flags &amp;amp; IFF_PROMISC) {
 		rx_ctl |= 0x02;
-	} else if (net-&amp;gt;flags &amp;amp; IFF_ALLMULTI || net-&amp;gt;mc_count &amp;gt; QF_MCAST_MAX) {
+	} else if (net-&amp;gt;flags &amp;amp; IFF_ALLMULTI || netdev_mc_count(net) &amp;gt; QF_MCAST_MAX) {
 		rx_ctl |= 0x04;
-	} else if (net-&amp;gt;mc_count) {
-		struct dev_mc_list *mc_list = net-&amp;gt;mc_list;
-		int i;
+	} else if (netdev_mc_count(net)) {
+		struct netdev_hw_addr *hw_addr;
 
-		for (i = 0; i &amp;lt; net-&amp;gt;mc_count; i++, mc_list = mc_list-&amp;gt;next) {
-			u32 crc = ether_crc(ETH_ALEN, mc_list-&amp;gt;dmi_addr) &amp;gt;&amp;gt; 26;
+		netdev_for_each_mc_addr(hw_addr, net) {
+			u32 crc = ether_crc(ETH_ALEN, hw_addr-&amp;gt;addr) &amp;gt;&amp;gt; 26;
 			hashes[crc &amp;gt;&amp;gt; 3] |= 1 &amp;lt;&amp;lt; (crc &amp;amp; 0x7);
 		}
 	}
@@ -413,9 +412,9 @@
 
 	/* power up and reset phy */
 	qf_write_reg(dev, PRR, 1);
-	udelay(20 * 1000);	// at least 10ms, here 20ms for safe
+	mdelay(20);	// at least 10ms, here 20ms for safe
 	qf_write_reg(dev, PRR, 0);
-	udelay(2 * 1000);	// at least 1ms, here 2ms for reading right register
+	mdelay(2);	// at least 1ms, here 2ms for reading right register
 
 	/* receive broadcast packets */
 	qf9700_set_multicast(dev-&amp;gt;net);
diff -ur b/qf9700.h a/qf9700.h
--- b/qf9700.h	2010-10-09 16:51:00.000000000 +0800
+++ a/qf9700.h	2014-04-15 17:20:23.000000000 +0800
@@ -150,4 +150,21 @@
 #define	QF_TX_OVERHEAD		2	// 2bytes header
 #define	QF_RX_OVERHEAD		7	// 3bytes header + 4crc tail
 
+#ifdef DEBUG
+#define devdbg(usbnet, fmt, arg...) \
+        printk(KERN_DEBUG &quot;%s: &quot; fmt &quot;\n&quot; , (usbnet)-&amp;gt;net-&amp;gt;name , ## arg)
+#else
+#define devdbg(usbnet, fmt, arg...) \
+        ({ if (0) printk(KERN_DEBUG &quot;%s: &quot; fmt &quot;\n&quot; , (usbnet)-&amp;gt;net-&amp;gt;name , \
+                ## arg); 0; })
+#endif
+
+#define deverr(usbnet, fmt, arg...) \
+        printk(KERN_ERR &quot;%s: &quot; fmt &quot;\n&quot; , (usbnet)-&amp;gt;net-&amp;gt;name , ## arg)
+#define devwarn(usbnet, fmt, arg...) \
+        printk(KERN_WARNING &quot;%s: &quot; fmt &quot;\n&quot; , (usbnet)-&amp;gt;net-&amp;gt;name , ## arg)
+
+#define devinfo(usbnet, fmt, arg...) \
+        printk(KERN_INFO &quot;%s: &quot; fmt &quot;\n&quot; , (usbnet)-&amp;gt;net-&amp;gt;name , ## arg); \
+
 /*----------------------------------------------------------------------------------------------*/



点此下载源文件及补丁文件。
</content>
      <categories>
        
          <category> Linux </category>
        
      </categories>
      <tags>
        
          <tag> linux </tag>
        
          <tag> driver </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Marvel 88w8686 Linux驱动分析</title>
      <url>/2014/04/14/marvel_88w8686_wifi_linux_driver_analysis/</url>
      <content type="text">由于编写Marvel 88w8686 wlan模块SPI接口的stm32驱动的需要，对Marvel 88w8686 Linux SPI接口的驱动进行了分析和参考。



#Marvel驱动的使用#

88w8686的Linux驱动是通过模块方式载入内核的，在使用时加载进去就行了，88w8686的Linux驱动还包含了sdio的驱动，加载时，还必须加载sdio驱动。在运行make命令进行编译后，会生成sdio.o和sd8386.o文件，在终端下输入下列命令进行加载：

insmod sdio.o
insmod sd8385.o



#Marvel驱动源码分析#

了解完如何使用Marvel 88w8686 Linux驱动后，便可以进行驱动源码的分析。源码点击此处下载。

##源码目录结构##

源码的目录结构如下：

.
├─app
│  └─wlanconfig
├─config
├─if
│  └─if_gspi
├─io
│  └─gspi
│      └─pxa270
├─os
│  └─linux
└─wlan



其中app文件夹是驱动自带的wlanconfig工具，用于配置wifi的参数，本文不进行分析。config文件夹包含的是一些配置文件，不进行分析。if文件夹包含的是关于GSPI操作的接口，包括固件。io文件夹包含的是GSPI驱动。os文件夹包含的是与系统相关的操作与头文件。wlan文件夹是wifi驱动的主要目录，在本文进行重点分析。

##驱动的启动流程##

由上文可知，wlan驱动是通过insmod进加载的。在文件wlan/wlan_main.c末尾处可以看到：

module_init(wlan_init_module);
module_exit(wlan_cleanup_module);

MODULE_DESCRIPTION(&quot;M-WLAN Driver&quot;);
MODULE_AUTHOR(&quot;Marvell International Ltd.&quot;);



这几个宏说明了wlan驱动模块的入口，知道其初始化函数是wlan_init_module。

再来看看wlan_init_module函数，在其函数中，调用了以下函数对网卡插入和移除时调用的函数进行了注册，即当电脑检测到网卡时有调用wlan_add_card。

sbi_register(wlan_add_card, wlan_remove_card, NULL)



在wlan_add_card中，进行初始化后，以下函数启动了内核主线程wlan_service_main_thread。

wlan_create_thread(wlan_service_main_thread, &amp;amp;priv-&amp;gt;MainThread, &quot;wlan_main_service&quot;)



###内核主线程###

内核主线程wlan_service_main_thread承担了wlan驱动的主要工作，它主要是处理wlan固件的事件，wlan固件接受到的数据和内核传来的数据。

在wlan_service_main_thread函数中有一个for死循环，所有数据处理都在循环里面。

在主循环里面，首先调用：

OS_SET_THREAD_STATE(TASK_INTERRUPTIBLE);
...
schedule();



让主线程进入可中断的等待模式，等到事件到来。当主线程被唤醒时，即有数据要处理，便调用：

sbi_get_int_status(priv, &amp;amp;ireg)；
...
Adapter-&amp;gt;HisRegCpy |= ireg;



先读取网卡固件发来的数据及标志位，将标志位存入Adapter-&amp;gt;HisRegCpy。

紧接着便对标志位进行判断：

/* Command response? */
if (Adapter-&amp;gt;HisRegCpy &amp;amp; HIS_CmdUpLdRdy) {
	PRINTM(INFO, &quot;main-thread: Cmd response ready.\n&quot;);

	OS_INT_DISABLE;
	Adapter-&amp;gt;HisRegCpy &amp;amp;= ~HIS_CmdUpLdRdy;
	OS_INT_RESTORE;

	wlan_process_rx_command(priv);
}

/* Any received data? */
if (Adapter-&amp;gt;HisRegCpy &amp;amp; HIS_RxUpLdRdy) {
	PRINTM(INFO, &quot;main-thread: Rx Packet ready.\n&quot;);
	
	OS_INT_DISABLE;
	Adapter-&amp;gt;HisRegCpy &amp;amp;= ~HIS_RxUpLdRdy;
	OS_INT_RESTORE;

	wlan_send_rxskbQ(priv);
}

/* Any Card Event */
if (Adapter-&amp;gt;HisRegCpy &amp;amp; HIS_CardEvent) {
	PRINTM(INFO, &quot;main-thread: Card Event Activity.\n&quot;);

	OS_INT_DISABLE;
	Adapter-&amp;gt;HisRegCpy &amp;amp;= ~HIS_CardEvent;
	OS_INT_RESTORE;

	if (sbi_read_event_cause(priv)) {
		PRINTM(MSG, &quot;main-thread: sbi_read_event_cause failed.\n&quot;);
		continue;
	}
	wlan_process_event(priv);
}



并且调用相应的处理函数，对数据进行处理。

当然进程中还对wlan的PS（Power Save）模式和WMM（WiFi-MultiMedia）进行判断处理，本文不进行分析。

接着，便对内核发来的命令进行处理（比如说连接命令，扫描命令）：

/* Execute the next command */
if (!priv-&amp;gt;wlan_dev.dnld_sent &amp;amp;&amp;amp; !Adapter-&amp;gt;CurCmd) {
	ExecuteNextCommand(priv);
}



当然，之后便进入等待事件状态，重复以上过程。

###wlan固件数据/事件###

当wlan固件有数据/事件时，GSPI驱动会产生中断，它的中断处理函数为sbi_interrupt，在sbi_interrupt中调用了wlan_interrupt,在wlan_interrupt中，调用

wake_up_interruptible(&amp;amp;priv-&amp;gt;MainThread.waitQ);



唤醒了主线程，对数据进行处理。上面介绍过，主线程调用sbi_get_int_status(priv, &amp;amp;ireg)读取数据和标志位。

###应用层调用驱动接口###

该wlan驱动接口是wext（Wireless Extensions无线扩展接口）。wext的接口实现上，应用层采用ioctl方式访问驱动，设置无线参数或者获取无线参数，配置无线驱动进行联网操作。无线驱动事件到应用层的传递采用的netlink socket技术，一种netlink route消息技术。这也是很多其他类型的驱动标准的实现方法。具体调用方法可以参考wlanconfig，比如说

ioctl(sockfd, SIOCGIWSCAN, &amp;amp;iwr));



调用wlan驱动扫描命令。如下函数

s = socket(PF_INET, SOCK_DGRAM, 0);



新建了一个netlink连接。

所有的ioctl的回调函数在，wlan_wext.c的wlan_handler数组中，这里对SIOCGIWSCAN即wlan扫描进行分析。可以看到wlan扫描的回调函数是wlan_get_scan和wlan_set_scan。

先来看看wlan_set_scan，在wlan_set_scan函数中又调用了wlan_scan_networks,在wlan_scan_networks中调用了wlan_scan_channel_list将命令添加到命令队列中，并等待命令执行响应，然后调用wlan_scan_process_results更新priv中的扫描表。

在函数wlan_scan_channel_list中调用PrepareAndSendCommand将命令添加到命令列表。等发送到固件的数据和固件发送过来的数据都存在CmdNode-&amp;gt;BufVirtualAddr指针指向的数据中，接着调用

QueueCmd(Adapter, CmdNode, TRUE);
wake_up_interruptible(&amp;amp;priv-&amp;gt;MainThread.waitQ);



将命令加入命令队列，接着唤醒主线程处理命令，然后执行如下函数

wait_event_interruptible(CmdNode-&amp;gt;cmdwait_q, CmdNode-&amp;gt;CmdWaitQWoken);



等待结果，当CmdNode-&amp;gt;CmdWaitQWoken为TRUE时唤醒。

在主线程中，由上面知道，调用ExecuteNextCommand执行内核发来的命令。在ExecuteNextCommand函数中调用DownloadCommandToStation下载命令，DownloadCommandToStation中，先调用sbi_host_to_card下载命令，然后调用ModTimer进行超时时重新发送。

接下来，便是等待响应，当固件对发来的命令响应时，会触发中断，如上文说的调用wlan_process_rx_command处理固件对命令的响应。在wlan_process_rx_command中处理完成之后，会调用CleanupAndInsertCmd回收命令，此时的CmdNode-&amp;gt;CmdWaitQWoken为TRUE，下次schedule时便，唤醒上面等待命令响应的线程，让其继续执行。

整个驱动运行的流程便是这样子。
</content>
      <categories>
        
          <category> Linux </category>
        
      </categories>
      <tags>
        
          <tag> wifi </tag>
        
          <tag> linux </tag>
        
          <tag> driver </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>强化你的Terminal IDE——在android平板/手机上编写C/C++</title>
      <url>/2012/11/24/c_on_android/</url>
      <content type="text">Terminal IDE是一个可扩展的终端应用，其包含了全功能的Java/HTML/Android开发套件。Terminal IDE集成了VIM, ssh, git等多个功能，其中强大之处，大家自己发觉，如果你用惯了Linux下的shell命令，那么用Terminal IDE你将会得心应手，喜欢上它的。



虽然Terminal IDE很强大，可以编写Java，android，但它没有gcc/g++。没关系，Terminal IDE强大之处就在于它是可拓展的，具体可以看它的Help。此处，我说明一下，如何把gcc/g++加入Terminal IDE，其实就是将linux-arm-gcc加入Terminal IDE 。

首先，将linux-arm-gcc解压到Terminal IDE中的~/system目录下(不是系统的/system/，其真正目录为:data/data/com.spartacusrex.spartacuside/files/system)。

修改该’gcc’目录为可读写，在Terminal IDE下执行

chmod -R 777 ./gcc



修改~(即data/data/com.spartacusrex.spartacuside/files/)目录下的.bashrc文件。添加需要的环境变量，在~/.bashrc文件添加如下环境变量：

export CPLUS_INCLUDE_PATH=$IDESYSTEM/gcc/arm-linux-androideabi/c++/include:$CPLUS_INCLUDE_PATH
export C_INCLUDE_PATH=$IDESYSTEM/gcc/arm-linux-androideabi/include:$C_INCLUDE_PATH
export PATH=$IDESYSTEM/gcc/bin:$PATH



将gcc/bin下的相应文件改一下名，改为gcc和g++。

再重启Terminal IDE后(需按TerminalIDE的Shutdown按钮)，便可以使用gcc和g++进行c++/c的编译，如下：

vim a.cpp   //写入代吗
g++ a.cpp   //编译
./a.out     //运行



此时，再用otg接个键盘或者用蓝牙键盘的话，那么整个apad就相当于你的电脑，得心应手。

如果你熟悉Linux和vim，以上方法是不错的选择，如果不熟悉的话，可以用C4droid。这里在贴出几个工具：（下载地址可以自己搜，我只贴出GooglePlay上的地址。）

　　AIDE：可以在android平板/手机上编写android应用，编译后可直接安装。

　　C4droid：可以在android平板/手机上编写并编译c/c++，不过不够强大。但比较容易安装。

　　ADDI：可以在android平板/手机上执行少量的matlab指令。

以上适合apad+键盘，如果没有键盘的话，我觉得还是别折腾了，没有这个必要吧。写一写小程序还是可以的，大的项目就不行了，编译会很慢的。
</content>
      <categories>
        
          <category> Android </category>
        
      </categories>
      <tags>
        
          <tag> android </tag>
        
          <tag> cpp </tag>
        
          <tag> c </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
